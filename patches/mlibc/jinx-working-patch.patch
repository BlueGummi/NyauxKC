diff --git mlibc-clean/meson.build mlibc-workdir/meson.build
index a460a6d..7dde217 100644
--- mlibc-clean/meson.build
+++ mlibc-workdir/meson.build
@@ -262,6 +262,10 @@ elif host_machine.system() == 'astral'
 	internal_conf.set10('MLIBC_MAP_DSO_SEGMENTS', true)
 	internal_conf.set10('MLIBC_MAP_FILE_WINDOWS', true)
 	subdir('sysdeps/astral')
+elif host_machine.system() == 'nyaux'
+	rtld_include_dirs += include_directories('sysdeps/nyaux/include')
+	libc_include_dirs += include_directories('sysdeps/nyaux/include')
+	subdir('sysdeps/nyaux')
 else
 	error('No sysdeps defined for OS: ' + host_machine.system())
 endif
diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..e034881 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -1,9 +1,10 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
+#include <mlibc/debug.hpp>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	mlibc::infoLogger() << "libc: backtrace() is not implemented!\n" << frg::endlog;
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git mlibc-clean/options/rtld/generic/linker.cpp mlibc-workdir/options/rtld/generic/linker.cpp
index 2806efa..e6cba9b 100644
--- mlibc-clean/options/rtld/generic/linker.cpp
+++ mlibc-workdir/options/rtld/generic/linker.cpp
@@ -4,19 +4,18 @@
 
 // keep a list of optional generic relocation types
 enum {
-	R_OFFSET =  (uintptr_t) -1,
+  R_OFFSET = (uintptr_t)-1,
 };
 
-
+#include <abi-bits/fcntl.h>
 #include <frg/manual_box.hpp>
 #include <frg/small_vector.hpp>
+#include <internal-config.h>
 #include <mlibc/allocator.hpp>
 #include <mlibc/debug.hpp>
-#include <mlibc/rtld-sysdeps.hpp>
 #include <mlibc/rtld-abi.hpp>
+#include <mlibc/rtld-sysdeps.hpp>
 #include <mlibc/thread.hpp>
-#include <abi-bits/fcntl.h>
-#include <internal-config.h>
 
 #include "elf.hpp"
 #include "linker.hpp"
@@ -27,7 +26,7 @@ uintptr_t libraryBase = 0x41000000;
 
 constexpr bool verbose = false;
 constexpr bool stillSlightlyVerbose = false;
-constexpr bool logBaseAddresses = false;
+constexpr bool logBaseAddresses = true;
 constexpr bool logRpath = false;
 constexpr bool logLdPath = false;
 constexpr bool logSymbolVersions = false;
@@ -46,13 +45,15 @@ constexpr inline uintptr_t tlsOffsetFromTp = 0;
 constexpr inline bool tlsAboveTp = true;
 constexpr inline ptrdiff_t tlsOffsetFromTp = -0x7000;
 #else
-#	error Unknown architecture
+#error Unknown architecture
 #endif
 
 extern DebugInterface globalDebugInterface;
 extern uintptr_t __stack_chk_guard;
 
-extern frg::manual_box<frg::small_vector<frg::string_view, MLIBC_NUM_DEFAULT_LIBRARY_PATHS, MemoryAllocator>> libraryPaths;
+extern frg::manual_box<frg::small_vector<
+    frg::string_view, MLIBC_NUM_DEFAULT_LIBRARY_PATHS, MemoryAllocator>>
+    libraryPaths;
 extern frg::manual_box<frg::vector<frg::string_view, MemoryAllocator>> preloads;
 
 #if MLIBC_STATIC_BUILD
@@ -75,31 +76,31 @@ size_t tlsMaxAlignment = 16;
 uint64_t rtsCounter = 2;
 
 bool trySeek(int fd, int64_t offset) {
-	off_t noff;
-	return mlibc::sys_seek(fd, offset, SEEK_SET, &noff) == 0;
+  off_t noff;
+  return mlibc::sys_seek(fd, offset, SEEK_SET, &noff) == 0;
 }
 
 bool tryReadExactly(int fd, void *data, size_t length) {
-	size_t offset = 0;
-	while(offset < length) {
-		ssize_t chunk;
-		if(mlibc::sys_read(fd, reinterpret_cast<char *>(data) + offset,
-				length - offset, &chunk))
-			return false;
-		__ensure(chunk > 0);
-		offset += chunk;
-	}
-	__ensure(offset == length);
-	return true;
+  size_t offset = 0;
+  while (offset < length) {
+    ssize_t chunk;
+    if (mlibc::sys_read(fd, reinterpret_cast<char *>(data) + offset,
+                        length - offset, &chunk))
+      return false;
+    __ensure(chunk > 0);
+    offset += chunk;
+  }
+  __ensure(offset == length);
+  return true;
 }
 
 void closeOrDie(int fd) {
-	if(mlibc::sys_close(fd))
-		__ensure(!"sys_close() failed");
+  if (mlibc::sys_close(fd))
+    __ensure(!"sys_close() failed");
 }
 
 uintptr_t alignUp(uintptr_t address, size_t align) {
-	return (address + align - 1) & ~(align - 1);
+  return (address + align - 1) & ~(align - 1);
 }
 
 // --------------------------------------------------------
@@ -107,285 +108,297 @@ uintptr_t alignUp(uintptr_t address, size_t align) {
 // --------------------------------------------------------
 
 ObjectRepository::ObjectRepository()
-: loadedObjects{getAllocator()},
-	dependencyQueue{getAllocator()},
-	_nameMap{frg::hash<frg::string_view>{}, getAllocator()},
-	_destructQueue{getAllocator()} {}
-
-SharedObject *ObjectRepository::injectObjectFromDts(frg::string_view name,
-		frg::string<MemoryAllocator> path, uintptr_t base_address,
-		elf_dyn *dynamic, uint64_t rts) {
-	__ensure(!findLoadedObject(name));
-
-	auto object = frg::construct<SharedObject>(getAllocator(),
-		name.data(), std::move(path), false, globalScope.get(), rts);
-	object->baseAddress = base_address;
-	object->dynamic = dynamic;
-	_parseDynamic(object);
-	_parseVerdef(object);
-
-	object->wasVisited = true;
-	dependencyQueue.push_back(object);
-	_addLoadedObject(object);
-
-	return object;
+    : loadedObjects{getAllocator()}, dependencyQueue{getAllocator()},
+      _nameMap{frg::hash<frg::string_view>{}, getAllocator()},
+      _destructQueue{getAllocator()} {}
+
+SharedObject *ObjectRepository::injectObjectFromDts(
+    frg::string_view name, frg::string<MemoryAllocator> path,
+    uintptr_t base_address, elf_dyn *dynamic, uint64_t rts) {
+  __ensure(!findLoadedObject(name));
+
+  auto object =
+      frg::construct<SharedObject>(getAllocator(), name.data(), std::move(path),
+                                   false, globalScope.get(), rts);
+  object->baseAddress = base_address;
+  object->dynamic = dynamic;
+  _parseDynamic(object);
+  _parseVerdef(object);
+
+  object->wasVisited = true;
+  dependencyQueue.push_back(object);
+  _addLoadedObject(object);
+
+  return object;
 }
 
-SharedObject *ObjectRepository::injectObjectFromPhdrs(frg::string_view name,
-		frg::string<MemoryAllocator> path, void *phdr_pointer,
-		size_t phdr_entry_size, size_t num_phdrs, void *entry_pointer,
-		uint64_t rts) {
-	__ensure(!findLoadedObject(name));
-
-	auto object = frg::construct<SharedObject>(getAllocator(),
-		name.data(), std::move(path), true, globalScope.get(), rts);
-	_fetchFromPhdrs(object, phdr_pointer, phdr_entry_size, num_phdrs, entry_pointer);
-	_parseDynamic(object);
-	_parseVerdef(object);
-
-	object->wasVisited = true;
-	dependencyQueue.push_back(object);
-	_addLoadedObject(object);
-
-	return object;
+SharedObject *ObjectRepository::injectObjectFromPhdrs(
+    frg::string_view name, frg::string<MemoryAllocator> path,
+    void *phdr_pointer, size_t phdr_entry_size, size_t num_phdrs,
+    void *entry_pointer, uint64_t rts) {
+  __ensure(!findLoadedObject(name));
+
+  auto object =
+      frg::construct<SharedObject>(getAllocator(), name.data(), std::move(path),
+                                   true, globalScope.get(), rts);
+  _fetchFromPhdrs(object, phdr_pointer, phdr_entry_size, num_phdrs,
+                  entry_pointer);
+  _parseDynamic(object);
+  _parseVerdef(object);
+
+  object->wasVisited = true;
+  dependencyQueue.push_back(object);
+  _addLoadedObject(object);
+
+  return object;
 }
 
-SharedObject *ObjectRepository::injectStaticObject(frg::string_view name,
-		frg::string<MemoryAllocator> path, void *phdr_pointer,
-		size_t phdr_entry_size, size_t num_phdrs, void *entry_pointer,
-		uint64_t rts) {
-	__ensure(!findLoadedObject(name));
-	auto object = frg::construct<SharedObject>(getAllocator(),
-		name.data(), std::move(path), true, globalScope.get(), rts);
-	_fetchFromPhdrs(object, phdr_pointer, phdr_entry_size, num_phdrs, entry_pointer);
+SharedObject *ObjectRepository::injectStaticObject(
+    frg::string_view name, frg::string<MemoryAllocator> path,
+    void *phdr_pointer, size_t phdr_entry_size, size_t num_phdrs,
+    void *entry_pointer, uint64_t rts) {
+  __ensure(!findLoadedObject(name));
+  auto object =
+      frg::construct<SharedObject>(getAllocator(), name.data(), std::move(path),
+                                   true, globalScope.get(), rts);
+  _fetchFromPhdrs(object, phdr_pointer, phdr_entry_size, num_phdrs,
+                  entry_pointer);
 
 #if MLIBC_STATIC_BUILD
-	object->initArray = reinterpret_cast<InitFuncPtr*>(__init_array_start);
-	object->initArraySize = static_cast<size_t>((uintptr_t)__init_array_end -
-			(uintptr_t)__init_array_start);
-	object->finiArray = reinterpret_cast<InitFuncPtr*>(__fini_array_start);
-	object->finiArraySize = static_cast<size_t>((uintptr_t)__fini_array_end -
-			(uintptr_t)__fini_array_start);
-	object->preInitArray = reinterpret_cast<InitFuncPtr*>(__preinit_array_start);
-	object->preInitArraySize = static_cast<size_t>((uintptr_t)__preinit_array_end -
-			(uintptr_t)__preinit_array_start);
+  object->initArray = reinterpret_cast<InitFuncPtr *>(__init_array_start);
+  object->initArraySize = static_cast<size_t>((uintptr_t)__init_array_end -
+                                              (uintptr_t)__init_array_start);
+  object->finiArray = reinterpret_cast<InitFuncPtr *>(__fini_array_start);
+  object->finiArraySize = static_cast<size_t>((uintptr_t)__fini_array_end -
+                                              (uintptr_t)__fini_array_start);
+  object->preInitArray = reinterpret_cast<InitFuncPtr *>(__preinit_array_start);
+  object->preInitArraySize = static_cast<size_t>(
+      (uintptr_t)__preinit_array_end - (uintptr_t)__preinit_array_start);
 #endif
 
-	_addLoadedObject(object);
+  _addLoadedObject(object);
 
-	return object;
+  return object;
 }
 
-frg::expected<LinkerError, SharedObject *> ObjectRepository::requestObjectWithName(frg::string_view name,
-		SharedObject *origin, Scope *localScope, bool createScope, uint64_t rts) {
-	if (auto obj = findLoadedObject(name))
-		return obj;
-
-	auto tryToOpen = [&] (const char *path) {
-		int fd;
-		if(auto x = mlibc::sys_open(path, O_RDONLY, 0, &fd); x) {
-			return -1;
-		}
-		return fd;
-	};
-
-	// TODO(arsen): this process can probably undergo heavy optimization, by
-	// preprocessing the rpath only once on parse
-	auto processRpath = [&] (frg::string_view path) {
-		frg::string<MemoryAllocator> sPath { getAllocator() };
-		if (path.starts_with("$ORIGIN")) {
-			frg::string_view dirname = origin->path;
-			auto lastsl = dirname.find_last('/');
-			if (lastsl != size_t(-1)) {
-				dirname = dirname.sub_string(0, lastsl);
-			} else {
-				dirname = ".";
-			}
-			sPath = frg::string<MemoryAllocator>{ getAllocator(), dirname };
-			sPath += path.sub_string(7, path.size() - 7);
-		} else {
-			sPath = frg::string<MemoryAllocator>{ getAllocator(), path };
-		}
-		if (sPath[sPath.size() - 1] != '/') {
-			sPath += '/';
-		}
-		sPath += name;
-		if (logRpath)
-			mlibc::infoLogger() << "rtld: trying in rpath " << sPath << frg::endlog;
-		int fd = tryToOpen(sPath.data());
-		if (logRpath && fd >= 0)
-			mlibc::infoLogger() << "rtld: found in rpath" << frg::endlog;
-		return frg::tuple { fd, std::move(sPath) };
-	};
-
-	frg::string<MemoryAllocator> chosenPath { getAllocator() };
-	int fd = -1;
-	if (origin && origin->runPath) {
-		size_t start = 0;
-		size_t idx = 0;
-		frg::string_view rpath { origin->runPath };
-		auto next = [&] () {
-			idx = rpath.find_first(':', start);
-			if (idx == (size_t)-1)
-				idx = rpath.size();
-		};
-		for (next(); idx < rpath.size(); next()) {
-			auto path = rpath.sub_string(start, idx - start);
-			start = idx + 1;
-			auto [fd_, fullPath] = processRpath(path);
-			if (fd_ != -1) {
-				fd = fd_;
-				chosenPath = std::move(fullPath);
-				break;
-			}
-		}
-		if (fd == -1) {
-			auto path = rpath.sub_string(start, rpath.size() - start);
-			auto [fd_, fullPath] = processRpath(path);
-			if (fd_ != -1) {
-				fd = fd_;
-				chosenPath = std::move(fullPath);
-			}
-		}
-	} else if (logRpath) {
-		mlibc::infoLogger() << "rtld: no rpath set for object" << frg::endlog;
-	}
-
-	for(size_t i = 0; i < libraryPaths->size() && fd == -1; i++) {
-		auto ldPath = (*libraryPaths)[i];
-		auto path = frg::string<MemoryAllocator>{getAllocator(), ldPath} + '/' + name;
-		if(logLdPath)
-			mlibc::infoLogger() << "rtld: Trying to load " << name << " from ldpath " << ldPath << "/" << frg::endlog;
-		fd = tryToOpen(path.data());
-		if(fd >= 0) {
-			chosenPath = std::move(path);
-			break;
-		}
-	}
-	if(fd == -1)
-		return LinkerError::notFound;
-
-	if (createScope) {
-		__ensure(localScope == nullptr);
-
-		// TODO: Free this when the scope is no longer needed.
-		localScope = frg::construct<Scope>(getAllocator());
-	}
-
-	__ensure(localScope != nullptr);
-
-	auto object = frg::construct<SharedObject>(getAllocator(),
-		name.data(), std::move(chosenPath), false, localScope, rts);
-
-	auto result = _fetchFromFile(object, fd);
-	closeOrDie(fd);
-	if(!result) {
-		frg::destruct(getAllocator(), object);
-		return result.error();
-	}
-
-	_parseDynamic(object);
-	_parseVerdef(object);
-	_addLoadedObject(object);
-
-	return object;
+frg::expected<LinkerError, SharedObject *>
+ObjectRepository::requestObjectWithName(frg::string_view name,
+                                        SharedObject *origin, Scope *localScope,
+                                        bool createScope, uint64_t rts) {
+  if (auto obj = findLoadedObject(name))
+    return obj;
+
+  auto tryToOpen = [&](const char *path) {
+    int fd;
+    if (auto x = mlibc::sys_open(path, O_RDONLY, 0, &fd); x) {
+      return -1;
+    }
+    return fd;
+  };
+
+  // TODO(arsen): this process can probably undergo heavy optimization, by
+  // preprocessing the rpath only once on parse
+  auto processRpath = [&](frg::string_view path) {
+    frg::string<MemoryAllocator> sPath{getAllocator()};
+    if (path.starts_with("$ORIGIN")) {
+      frg::string_view dirname = origin->path;
+      auto lastsl = dirname.find_last('/');
+      if (lastsl != size_t(-1)) {
+        dirname = dirname.sub_string(0, lastsl);
+      } else {
+        dirname = ".";
+      }
+      sPath = frg::string<MemoryAllocator>{getAllocator(), dirname};
+      sPath += path.sub_string(7, path.size() - 7);
+    } else {
+      sPath = frg::string<MemoryAllocator>{getAllocator(), path};
+    }
+    if (sPath[sPath.size() - 1] != '/') {
+      sPath += '/';
+    }
+    sPath += name;
+    if (logRpath)
+      mlibc::infoLogger() << "rtld: trying in rpath " << sPath << frg::endlog;
+    int fd = tryToOpen(sPath.data());
+    if (logRpath && fd >= 0)
+      mlibc::infoLogger() << "rtld: found in rpath" << frg::endlog;
+    return frg::tuple{fd, std::move(sPath)};
+  };
+
+  frg::string<MemoryAllocator> chosenPath{getAllocator()};
+  int fd = -1;
+  if (origin && origin->runPath) {
+    size_t start = 0;
+    size_t idx = 0;
+    frg::string_view rpath{origin->runPath};
+    auto next = [&]() {
+      idx = rpath.find_first(':', start);
+      if (idx == (size_t)-1)
+        idx = rpath.size();
+    };
+    for (next(); idx < rpath.size(); next()) {
+      auto path = rpath.sub_string(start, idx - start);
+      start = idx + 1;
+      auto [fd_, fullPath] = processRpath(path);
+      if (fd_ != -1) {
+        fd = fd_;
+        chosenPath = std::move(fullPath);
+        break;
+      }
+    }
+    if (fd == -1) {
+      auto path = rpath.sub_string(start, rpath.size() - start);
+      auto [fd_, fullPath] = processRpath(path);
+      if (fd_ != -1) {
+        fd = fd_;
+        chosenPath = std::move(fullPath);
+      }
+    }
+  } else if (logRpath) {
+    mlibc::infoLogger() << "rtld: no rpath set for object" << frg::endlog;
+  }
+
+  for (size_t i = 0; i < libraryPaths->size() && fd == -1; i++) {
+    auto ldPath = (*libraryPaths)[i];
+    auto path =
+        frg::string<MemoryAllocator>{getAllocator(), ldPath} + '/' + name;
+    if (logLdPath)
+      mlibc::infoLogger() << "rtld: Trying to load " << name << " from ldpath "
+                          << ldPath << "/" << frg::endlog;
+    fd = tryToOpen(path.data());
+    if (fd >= 0) {
+      chosenPath = std::move(path);
+      break;
+    }
+  }
+  if (fd == -1)
+    return LinkerError::notFound;
+
+  if (createScope) {
+    __ensure(localScope == nullptr);
+
+    // TODO: Free this when the scope is no longer needed.
+    localScope = frg::construct<Scope>(getAllocator());
+  }
+
+  __ensure(localScope != nullptr);
+
+  auto object = frg::construct<SharedObject>(getAllocator(), name.data(),
+                                             std::move(chosenPath), false,
+                                             localScope, rts);
+
+  auto result = _fetchFromFile(object, fd);
+  closeOrDie(fd);
+  if (!result) {
+    frg::destruct(getAllocator(), object);
+    return result.error();
+  }
+
+  _parseDynamic(object);
+  _parseVerdef(object);
+  _addLoadedObject(object);
+
+  return object;
 }
 
-frg::expected<LinkerError, SharedObject *> ObjectRepository::requestObjectAtPath(frg::string_view path,
-		Scope *localScope, bool createScope, uint64_t rts) {
-	// TODO: Support SONAME correctly.
-	auto lastSlash = path.find_last('/') + 1;
-	auto name = path;
-	if (!lastSlash) {
-		name = name.sub_string(lastSlash, path.size() - lastSlash);
-	}
-	if (auto obj = findLoadedObject(name))
-		return obj;
-
-	if (createScope) {
-		__ensure(localScope == nullptr);
-
-		// TODO: Free this when the scope is no longer needed.
-		localScope = frg::construct<Scope>(getAllocator());
-	}
-
-	__ensure(localScope != nullptr);
-
-	auto object = frg::construct<SharedObject>(getAllocator(),
-		name.data(), path.data(), false, localScope, rts);
-
-	frg::string<MemoryAllocator> no_prefix(getAllocator(), path);
-
-	int fd;
-	if(mlibc::sys_open((no_prefix + '\0').data(), O_RDONLY, 0, &fd)) {
-		frg::destruct(getAllocator(), object);
-		return LinkerError::notFound;
-	}
-	auto result = _fetchFromFile(object, fd);
-	closeOrDie(fd);
-	if(!result) {
-		frg::destruct(getAllocator(), object);
-		return result.error();
-	}
-
-	_parseDynamic(object);
-	_parseVerdef(object);
-	_addLoadedObject(object);
-
-	return object;
+frg::expected<LinkerError, SharedObject *>
+ObjectRepository::requestObjectAtPath(frg::string_view path, Scope *localScope,
+                                      bool createScope, uint64_t rts) {
+  // TODO: Support SONAME correctly.
+  auto lastSlash = path.find_last('/') + 1;
+  auto name = path;
+  if (!lastSlash) {
+    name = name.sub_string(lastSlash, path.size() - lastSlash);
+  }
+  if (auto obj = findLoadedObject(name))
+    return obj;
+
+  if (createScope) {
+    __ensure(localScope == nullptr);
+
+    // TODO: Free this when the scope is no longer needed.
+    localScope = frg::construct<Scope>(getAllocator());
+  }
+
+  __ensure(localScope != nullptr);
+
+  auto object = frg::construct<SharedObject>(
+      getAllocator(), name.data(), path.data(), false, localScope, rts);
+
+  frg::string<MemoryAllocator> no_prefix(getAllocator(), path);
+
+  int fd;
+  if (mlibc::sys_open((no_prefix + '\0').data(), O_RDONLY, 0, &fd)) {
+    frg::destruct(getAllocator(), object);
+    return LinkerError::notFound;
+  }
+  auto result = _fetchFromFile(object, fd);
+  closeOrDie(fd);
+  if (!result) {
+    frg::destruct(getAllocator(), object);
+    return result.error();
+  }
+
+  _parseDynamic(object);
+  _parseVerdef(object);
+  _addLoadedObject(object);
+
+  return object;
 }
 
-void ObjectRepository::discoverDependenciesFromLoadedObject(SharedObject *object) {
-	_discoverDependencies(object, object->localScope, object->objectRts);
-	_parseVerneed(object);
+void ObjectRepository::discoverDependenciesFromLoadedObject(
+    SharedObject *object) {
+  _discoverDependencies(object, object->localScope, object->objectRts);
+  _parseVerneed(object);
 }
 
 SharedObject *ObjectRepository::findCaller(void *addr) {
-	uintptr_t target = reinterpret_cast<uintptr_t>(addr);
-
-	for (auto [name, object] : _nameMap) {
-		// Search all PT_LOAD segments for the specified address.
-		for(size_t j = 0; j < object->phdrCount; j++) {
-			auto phdr = (elf_phdr *)((uintptr_t)object->phdrPointer + j * object->phdrEntrySize);
-			if (phdr->p_type == PT_LOAD) {
-				uintptr_t start = object->baseAddress + phdr->p_vaddr;
-				uintptr_t end = start + phdr->p_memsz;
-				if (start <= target && target < end)
-					return object;
-			}
-		}
-	}
-
-	return nullptr;
+  uintptr_t target = reinterpret_cast<uintptr_t>(addr);
+
+  for (auto [name, object] : _nameMap) {
+    // Search all PT_LOAD segments for the specified address.
+    for (size_t j = 0; j < object->phdrCount; j++) {
+      auto phdr = (elf_phdr *)((uintptr_t)object->phdrPointer +
+                               j * object->phdrEntrySize);
+      if (phdr->p_type == PT_LOAD) {
+        uintptr_t start = object->baseAddress + phdr->p_vaddr;
+        uintptr_t end = start + phdr->p_memsz;
+        if (start <= target && target < end)
+          return object;
+      }
+    }
+  }
+
+  return nullptr;
 }
 
 SharedObject *ObjectRepository::findLoadedObject(frg::string_view name) {
-	auto it = _nameMap.get(name);
-	if (it)
-		return *it;
-
-	for (auto object : loadedObjects) {
-		// See if any object has a matching SONAME.
-		if (object->soName && name == object->soName)
-			return object;
-	}
-
-	// TODO: We should also look at the device and inode here as a fallback.
-	return nullptr;
+  auto it = _nameMap.get(name);
+  if (it)
+    return *it;
+
+  for (auto object : loadedObjects) {
+    // See if any object has a matching SONAME.
+    if (object->soName && name == object->soName)
+      return object;
+  }
+
+  // TODO: We should also look at the device and inode here as a fallback.
+  return nullptr;
 }
 
 void ObjectRepository::addObjectToDestructQueue(SharedObject *object) {
-	_destructQueue.push(object);
+  _destructQueue.push(object);
 }
 
 void doDestruct(SharedObject *object);
 
 void ObjectRepository::destructObjects() {
-	while (_destructQueue.size() > 0) {
-		auto top = _destructQueue.top();
-		doDestruct(top);
-		_destructQueue.pop();
-	}
+  while (_destructQueue.size() > 0) {
+    auto top = _destructQueue.top();
+    doDestruct(top);
+    _destructQueue.pop();
+  }
 }
 
 // --------------------------------------------------------
@@ -393,232 +406,237 @@ void ObjectRepository::destructObjects() {
 // --------------------------------------------------------
 
 void ObjectRepository::_fetchFromPhdrs(SharedObject *object, void *phdr_pointer,
-		size_t phdr_entry_size, size_t phdr_count, void *entry_pointer) {
-	__ensure(object->isMainObject);
-	object->phdrPointer = phdr_pointer;
-	object->phdrEntrySize = phdr_entry_size;
-	object->phdrCount = phdr_count;
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Loading " << object->name << frg::endlog;
-
-	// Note: the entry pointer is absolute and not relative to the base address.
-	object->entry = entry_pointer;
-
-	frg::optional<ptrdiff_t> dynamic_offset;
-	frg::optional<ptrdiff_t> tls_offset;
-
-	// segments are already mapped, so we just have to find the dynamic section
-	for(size_t i = 0; i < phdr_count; i++) {
-		auto phdr = (elf_phdr *)((uintptr_t)phdr_pointer + i * phdr_entry_size);
-		switch(phdr->p_type) {
-		case PT_PHDR:
-			// Determine the executable's base address (in the PIE case) by comparing
-			// the PHDR segment's load address against it's address in the ELF file.
-			object->baseAddress = reinterpret_cast<uintptr_t>(phdr_pointer) - phdr->p_vaddr;
-			if(verbose)
-				mlibc::infoLogger() << "rtld: Executable is loaded at "
-						<< (void *)object->baseAddress << frg::endlog;
-			break;
-		case PT_DYNAMIC:
-			dynamic_offset = phdr->p_vaddr;
-			break;
-		case PT_TLS: {
-			object->tlsSegmentSize = phdr->p_memsz;
-			object->tlsAlignment = phdr->p_align;
-			object->tlsImageSize = phdr->p_filesz;
-			tls_offset = phdr->p_vaddr;
-			break;
-		case PT_INTERP:
-			object->interpreterPath = frg::string<MemoryAllocator>{
-				(char*)(object->baseAddress + phdr->p_vaddr),
-					getAllocator()
-			};
-		} break;
-		default:
-			//FIXME warn about unknown phdrs
-			break;
-		}
-	}
-
-	if(dynamic_offset)
-		object->dynamic = (elf_dyn *)(object->baseAddress + *dynamic_offset);
-	if(tls_offset)
-		object->tlsImagePtr = (void *)(object->baseAddress + *tls_offset);
+                                       size_t phdr_entry_size,
+                                       size_t phdr_count, void *entry_pointer) {
+  __ensure(object->isMainObject);
+  object->phdrPointer = phdr_pointer;
+  object->phdrEntrySize = phdr_entry_size;
+  object->phdrCount = phdr_count;
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Loading " << object->name << frg::endlog;
+
+  // Note: the entry pointer is absolute and not relative to the base address.
+  object->entry = entry_pointer;
+
+  frg::optional<ptrdiff_t> dynamic_offset;
+  frg::optional<ptrdiff_t> tls_offset;
+
+  // segments are already mapped, so we just have to find the dynamic section
+  for (size_t i = 0; i < phdr_count; i++) {
+    auto phdr = (elf_phdr *)((uintptr_t)phdr_pointer + i * phdr_entry_size);
+    switch (phdr->p_type) {
+    case PT_PHDR:
+      // Determine the executable's base address (in the PIE case) by comparing
+      // the PHDR segment's load address against it's address in the ELF file.
+      object->baseAddress =
+          reinterpret_cast<uintptr_t>(phdr_pointer) - phdr->p_vaddr;
+      if (verbose)
+        mlibc::infoLogger() << "rtld: Executable is loaded at "
+                            << (void *)object->baseAddress << frg::endlog;
+      break;
+    case PT_DYNAMIC:
+      dynamic_offset = phdr->p_vaddr;
+      break;
+    case PT_TLS: {
+      object->tlsSegmentSize = phdr->p_memsz;
+      object->tlsAlignment = phdr->p_align;
+      object->tlsImageSize = phdr->p_filesz;
+      tls_offset = phdr->p_vaddr;
+      break;
+    case PT_INTERP:
+      object->interpreterPath = frg::string<MemoryAllocator>{
+          (char *)(object->baseAddress + phdr->p_vaddr), getAllocator()};
+    } break;
+    default:
+      // FIXME warn about unknown phdrs
+      break;
+    }
+  }
+
+  if (dynamic_offset)
+    object->dynamic = (elf_dyn *)(object->baseAddress + *dynamic_offset);
+  if (tls_offset)
+    object->tlsImagePtr = (void *)(object->baseAddress + *tls_offset);
 }
 
+frg::expected<LinkerError, void>
+ObjectRepository::_fetchFromFile(SharedObject *object, int fd) {
+  __ensure(!object->isMainObject);
 
-frg::expected<LinkerError, void> ObjectRepository::_fetchFromFile(SharedObject *object, int fd) {
-	__ensure(!object->isMainObject);
-
-	// read the elf file header
-	elf_ehdr ehdr;
-	if(!tryReadExactly(fd, &ehdr, sizeof(elf_ehdr)))
-		return LinkerError::fileTooShort;
+  // read the elf file header
+  elf_ehdr ehdr;
+  if (!tryReadExactly(fd, &ehdr, sizeof(elf_ehdr)))
+    return LinkerError::fileTooShort;
 
-	if(ehdr.e_ident[0] != 0x7F
-			|| ehdr.e_ident[1] != 'E'
-			|| ehdr.e_ident[2] != 'L'
-			|| ehdr.e_ident[3] != 'F')
-		return LinkerError::notElf;
+  if (ehdr.e_ident[0] != 0x7F || ehdr.e_ident[1] != 'E' ||
+      ehdr.e_ident[2] != 'L' || ehdr.e_ident[3] != 'F')
+    return LinkerError::notElf;
 
-	if((ehdr.e_type != ET_EXEC && ehdr.e_type != ET_DYN)
-			|| ehdr.e_machine != ELF_MACHINE
-			|| ehdr.e_ident[EI_CLASS] != ELF_CLASS)
-		return LinkerError::wrongElfType;
+  if ((ehdr.e_type != ET_EXEC && ehdr.e_type != ET_DYN) ||
+      ehdr.e_machine != ELF_MACHINE || ehdr.e_ident[EI_CLASS] != ELF_CLASS)
+    return LinkerError::wrongElfType;
 
-	// read the elf program headers
-	auto phdr_buffer = (char *)getAllocator().allocate(ehdr.e_phnum * ehdr.e_phentsize);
-	if(!phdr_buffer)
-		return LinkerError::outOfMemory;
+  // read the elf program headers
+  auto phdr_buffer =
+      (char *)getAllocator().allocate(ehdr.e_phnum * ehdr.e_phentsize);
+  if (!phdr_buffer)
+    return LinkerError::outOfMemory;
 
-	if(!trySeek(fd, ehdr.e_phoff)) {
-		getAllocator().deallocate(phdr_buffer, ehdr.e_phnum * ehdr.e_phentsize);
-		return LinkerError::invalidProgramHeader;
-	}
-	if(!tryReadExactly(fd, phdr_buffer, ehdr.e_phnum * ehdr.e_phentsize)) {
-		getAllocator().deallocate(phdr_buffer, ehdr.e_phnum * ehdr.e_phentsize);
-		return LinkerError::invalidProgramHeader;
-	}
+  if (!trySeek(fd, ehdr.e_phoff)) {
+    getAllocator().deallocate(phdr_buffer, ehdr.e_phnum * ehdr.e_phentsize);
+    return LinkerError::invalidProgramHeader;
+  }
+  if (!tryReadExactly(fd, phdr_buffer, ehdr.e_phnum * ehdr.e_phentsize)) {
+    getAllocator().deallocate(phdr_buffer, ehdr.e_phnum * ehdr.e_phentsize);
+    return LinkerError::invalidProgramHeader;
+  }
 
-	object->phdrPointer = phdr_buffer;
-	object->phdrCount = ehdr.e_phnum;
-	object->phdrEntrySize = ehdr.e_phentsize;
+  object->phdrPointer = phdr_buffer;
+  object->phdrCount = ehdr.e_phnum;
+  object->phdrEntrySize = ehdr.e_phentsize;
 
-	// Allocate virtual address space for the DSO.
-	constexpr size_t hugeSize = 0x200000;
+  // Allocate virtual address space for the DSO.
+  constexpr size_t hugeSize = 0x200000;
 
-	uintptr_t highest_address = 0;
-	for(int i = 0; i < ehdr.e_phnum; i++) {
-		auto phdr = (elf_phdr *)(phdr_buffer + i * ehdr.e_phentsize);
+  uintptr_t highest_address = 0;
+  for (int i = 0; i < ehdr.e_phnum; i++) {
+    auto phdr = (elf_phdr *)(phdr_buffer + i * ehdr.e_phentsize);
 
-		if(phdr->p_type != PT_LOAD)
-			continue;
+    if (phdr->p_type != PT_LOAD)
+      continue;
 
-		auto limit = phdr->p_vaddr + phdr->p_memsz;
-		if(limit > highest_address)
-			highest_address = limit;
-	}
+    auto limit = phdr->p_vaddr + phdr->p_memsz;
+    if (limit > highest_address)
+      highest_address = limit;
+  }
 
-	__ensure(!(object->baseAddress & (hugeSize - 1)));
+  __ensure(!(object->baseAddress & (hugeSize - 1)));
 
-	highest_address = (highest_address + mlibc::page_size - 1) & ~(mlibc::page_size - 1);
+  highest_address =
+      (highest_address + mlibc::page_size - 1) & ~(mlibc::page_size - 1);
 
 #if MLIBC_MMAP_ALLOCATE_DSO
-	void *mappedAddr = nullptr;
-
-	if (mlibc::sys_vm_map(nullptr,
-			highest_address - object->baseAddress, PROT_NONE,
-			MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, &mappedAddr)) {
-		mlibc::infoLogger() << "sys_vm_map failed when allocating address space for DSO \""
-				<< object->name << "\""
-				<< ", base " << (void *)object->baseAddress
-				<< ", requested " << (highest_address - object->baseAddress) << " bytes"
-				<< frg::endlog;
-		getAllocator().deallocate(phdr_buffer, ehdr.e_phnum * ehdr.e_phentsize);
-		return LinkerError::outOfMemory;
-	}
-
-	object->baseAddress = reinterpret_cast<uintptr_t>(mappedAddr);
+  void *mappedAddr = nullptr;
+
+  if (mlibc::sys_vm_map(nullptr, highest_address - object->baseAddress,
+                        PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0,
+                        &mappedAddr)) {
+    mlibc::infoLogger()
+        << "sys_vm_map failed when allocating address space for DSO \""
+        << object->name << "\"" << ", base " << (void *)object->baseAddress
+        << ", requested " << (highest_address - object->baseAddress) << " bytes"
+        << frg::endlog;
+    getAllocator().deallocate(phdr_buffer, ehdr.e_phnum * ehdr.e_phentsize);
+    return LinkerError::outOfMemory;
+  }
+
+  object->baseAddress = reinterpret_cast<uintptr_t>(mappedAddr);
 #else
-	object->baseAddress = libraryBase;
-	libraryBase += (highest_address + (hugeSize - 1)) & ~(hugeSize - 1);
+  object->baseAddress = libraryBase;
+  libraryBase += (highest_address + (hugeSize - 1)) & ~(hugeSize - 1);
 #endif
 
-	if(verbose || logBaseAddresses)
-		mlibc::infoLogger() << "rtld: Loading " << object->name
-				<< " at " << (void *)object->baseAddress << frg::endlog;
-
-	// Load all segments.
-	constexpr size_t pageSize = 0x1000;
-	for(int i = 0; i < ehdr.e_phnum; i++) {
-		auto phdr = (elf_phdr *)(phdr_buffer + i * ehdr.e_phentsize);
-
-		if(phdr->p_type == PT_LOAD) {
-			size_t misalign = phdr->p_vaddr & (pageSize - 1);
-			if(!phdr->p_memsz)
-				continue;
-			__ensure(phdr->p_memsz >= phdr->p_filesz);
-
-			// If the following condition is violated, we cannot use mmap() the segment;
-			// however, GCC only generates ELF files that satisfy this.
-			__ensure(misalign == (phdr->p_offset & (pageSize - 1)));
-
-			auto map_address = object->baseAddress + phdr->p_vaddr - misalign;
-			auto backed_map_size = (phdr->p_filesz + misalign + pageSize - 1) & ~(pageSize - 1);
-			auto total_map_size = (phdr->p_memsz + misalign + pageSize - 1) & ~(pageSize - 1);
-
-			int prot = 0;
-			if(phdr->p_flags & PF_R)
-				prot |= PROT_READ;
-			if(phdr->p_flags & PF_W)
-				prot |= PROT_WRITE;
-			if(phdr->p_flags & PF_X)
-				prot |= PROT_EXEC;
-
-			#if MLIBC_MAP_DSO_SEGMENTS
-				void *map_pointer;
-				if(mlibc::sys_vm_map(reinterpret_cast<void *>(map_address),
-						backed_map_size, PROT_READ | PROT_WRITE,
-						MAP_PRIVATE | MAP_FIXED, fd, phdr->p_offset - misalign, &map_pointer))
-					__ensure(!"sys_vm_map failed");
-				if(total_map_size > backed_map_size)
-					if(mlibc::sys_vm_map(reinterpret_cast<void *>(map_address + backed_map_size),
-							total_map_size - backed_map_size, PROT_READ | PROT_WRITE,
-							MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0, &map_pointer))
-						__ensure(!"sys_vm_map failed");
-
-				if(mlibc::sys_vm_readahead)
-					if(mlibc::sys_vm_readahead(reinterpret_cast<void *>(map_address),
-							backed_map_size))
-						mlibc::infoLogger() << "mlibc: sys_vm_readahead() failed in ld.so"
-								<< frg::endlog;
-
-				// Clear the trailing area at the end of the backed mapping.
-				// We do not clear the leading area; programs are not supposed to access it.
-				memset(reinterpret_cast<void *>(map_address + misalign + phdr->p_filesz),
-						0, phdr->p_memsz - phdr->p_filesz);
-			#else
-				(void)backed_map_size;
-
-				void *map_pointer;
-				if(mlibc::sys_vm_map(reinterpret_cast<void *>(map_address),
-						total_map_size, PROT_READ | PROT_WRITE,
-						MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0, &map_pointer))
-					__ensure(!"sys_vm_map failed");
-
-				__ensure(trySeek(fd, phdr->p_offset));
-				__ensure(tryReadExactly(fd, reinterpret_cast<char *>(map_address) + misalign,
-						phdr->p_filesz));
-			#endif
-			if (!mlibc::sys_vm_protect) {
-				__ensure(!"sys_vm_protect not provided");
-			}
-			if (mlibc::sys_vm_protect(reinterpret_cast<void *>(map_address), total_map_size, prot)) {
-				__ensure(!"sys_vm_protect failed");
-			}
-		}else if(phdr->p_type == PT_TLS) {
-			object->tlsSegmentSize = phdr->p_memsz;
-			object->tlsAlignment = phdr->p_align;
-			object->tlsImageSize = phdr->p_filesz;
-			object->tlsImagePtr = (void *)(object->baseAddress + phdr->p_vaddr);
-		}else if(phdr->p_type == PT_DYNAMIC) {
-			object->dynamic = (elf_dyn *)(object->baseAddress + phdr->p_vaddr);
-		}else if(phdr->p_type == PT_INTERP
-				|| phdr->p_type == PT_PHDR
-				|| phdr->p_type == PT_NOTE
-				|| phdr->p_type == PT_RISCV_ATTRIBUTES
-				|| phdr->p_type == PT_GNU_EH_FRAME
-				|| phdr->p_type == PT_GNU_RELRO
-				|| phdr->p_type == PT_GNU_STACK
-				|| phdr->p_type == PT_GNU_PROPERTY) {
-			// ignore the phdr
-		}else{
-			mlibc::panicLogger() << "Unexpected PHDR type 0x"
-					<< frg::hex_fmt(phdr->p_type) << " in DSO " << object->name << frg::endlog;
-		}
-	}
-
-	return frg::success;
+  if (verbose || logBaseAddresses)
+    mlibc::infoLogger() << "rtld: Loading " << object->name << " at "
+                        << (void *)object->baseAddress << frg::endlog;
+
+  // Load all segments.
+  constexpr size_t pageSize = 0x1000;
+  for (int i = 0; i < ehdr.e_phnum; i++) {
+    auto phdr = (elf_phdr *)(phdr_buffer + i * ehdr.e_phentsize);
+
+    if (phdr->p_type == PT_LOAD) {
+      size_t misalign = phdr->p_vaddr & (pageSize - 1);
+      if (!phdr->p_memsz)
+        continue;
+      __ensure(phdr->p_memsz >= phdr->p_filesz);
+
+      // If the following condition is violated, we cannot use mmap() the
+      // segment; however, GCC only generates ELF files that satisfy this.
+      __ensure(misalign == (phdr->p_offset & (pageSize - 1)));
+
+      auto map_address = object->baseAddress + phdr->p_vaddr - misalign;
+      auto backed_map_size =
+          (phdr->p_filesz + misalign + pageSize - 1) & ~(pageSize - 1);
+      auto total_map_size =
+          (phdr->p_memsz + misalign + pageSize - 1) & ~(pageSize - 1);
+
+      int prot = 0;
+      if (phdr->p_flags & PF_R)
+        prot |= PROT_READ;
+      if (phdr->p_flags & PF_W)
+        prot |= PROT_WRITE;
+      if (phdr->p_flags & PF_X)
+        prot |= PROT_EXEC;
+
+#if MLIBC_MAP_DSO_SEGMENTS
+      void *map_pointer;
+      if (mlibc::sys_vm_map(reinterpret_cast<void *>(map_address),
+                            backed_map_size, PROT_READ | PROT_WRITE,
+                            MAP_PRIVATE | MAP_FIXED, fd,
+                            phdr->p_offset - misalign, &map_pointer))
+        __ensure(!"sys_vm_map failed");
+      if (total_map_size > backed_map_size)
+        if (mlibc::sys_vm_map(
+                reinterpret_cast<void *>(map_address + backed_map_size),
+                total_map_size - backed_map_size, PROT_READ | PROT_WRITE,
+                MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0, &map_pointer))
+          __ensure(!"sys_vm_map failed");
+
+      if (mlibc::sys_vm_readahead)
+        if (mlibc::sys_vm_readahead(reinterpret_cast<void *>(map_address),
+                                    backed_map_size))
+          mlibc::infoLogger()
+              << "mlibc: sys_vm_readahead() failed in ld.so" << frg::endlog;
+
+      // Clear the trailing area at the end of the backed mapping.
+      // We do not clear the leading area; programs are not supposed to access
+      // it.
+      memset(reinterpret_cast<void *>(map_address + misalign + phdr->p_filesz),
+             0, phdr->p_memsz - phdr->p_filesz);
+#else
+      (void)backed_map_size;
+
+      void *map_pointer;
+      if (mlibc::sys_vm_map(reinterpret_cast<void *>(map_address),
+                            total_map_size, PROT_READ | PROT_WRITE,
+                            MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0,
+                            &map_pointer))
+        __ensure(!"sys_vm_map failed");
+
+      __ensure(trySeek(fd, phdr->p_offset));
+      __ensure(tryReadExactly(fd,
+                              reinterpret_cast<char *>(map_address) + misalign,
+                              phdr->p_filesz));
+#endif
+      if (!mlibc::sys_vm_protect) {
+        __ensure(!"sys_vm_protect not provided");
+      }
+      if (mlibc::sys_vm_protect(reinterpret_cast<void *>(map_address),
+                                total_map_size, prot)) {
+        __ensure(!"sys_vm_protect failed");
+      }
+    } else if (phdr->p_type == PT_TLS) {
+      object->tlsSegmentSize = phdr->p_memsz;
+      object->tlsAlignment = phdr->p_align;
+      object->tlsImageSize = phdr->p_filesz;
+      object->tlsImagePtr = (void *)(object->baseAddress + phdr->p_vaddr);
+    } else if (phdr->p_type == PT_DYNAMIC) {
+      object->dynamic = (elf_dyn *)(object->baseAddress + phdr->p_vaddr);
+    } else if (phdr->p_type == PT_INTERP || phdr->p_type == PT_PHDR ||
+               phdr->p_type == PT_NOTE || phdr->p_type == PT_RISCV_ATTRIBUTES ||
+               phdr->p_type == PT_GNU_EH_FRAME ||
+               phdr->p_type == PT_GNU_RELRO || phdr->p_type == PT_GNU_STACK ||
+               phdr->p_type == PT_GNU_PROPERTY) {
+      // ignore the phdr
+    } else {
+      mlibc::panicLogger() << "Unexpected PHDR type 0x"
+                           << frg::hex_fmt(phdr->p_type) << " in DSO "
+                           << object->name << frg::endlog;
+    }
+  }
+
+  return frg::success;
 }
 
 // --------------------------------------------------------
@@ -626,407 +644,414 @@ frg::expected<LinkerError, void> ObjectRepository::_fetchFromFile(SharedObject *
 // --------------------------------------------------------
 
 void ObjectRepository::_parseDynamic(SharedObject *object) {
-	if(!object->dynamic)
-		mlibc::infoLogger() << "ldso: Object '" << object->name
-				<< "' does not have a dynamic section" << frg::endlog;
-	__ensure(object->dynamic);
-
-	// Fix up these offsets to addresses after the loop, since the
-	// addresses depend on the value of DT_STRTAB.
-	frg::optional<ptrdiff_t> runpath_offset;
-	/* If true, ignore the RPATH.  */
-	bool runpath_found = false;
-	frg::optional<ptrdiff_t> soname_offset;
-
-	for(size_t i = 0; object->dynamic[i].d_tag != DT_NULL; i++) {
-		elf_dyn *dynamic = &object->dynamic[i];
-		switch(dynamic->d_tag) {
-		// handle hash table, symbol table and string table
-		case DT_HASH:
-			object->hashStyle = HashStyle::systemV;
-			object->hashTableOffset = dynamic->d_un.d_ptr;
-			break;
-		case DT_GNU_HASH:
-			object->hashStyle = HashStyle::gnu;
-			object->hashTableOffset = dynamic->d_un.d_ptr;
-			break;
-		case DT_STRTAB:
-			object->stringTableOffset = dynamic->d_un.d_ptr;
-			break;
-		case DT_STRSZ:
-			break; // we don't need the size of the string table
-		case DT_SYMTAB:
-			object->symbolTableOffset = dynamic->d_un.d_ptr;
-			break;
-		case DT_SYMENT:
-			__ensure(dynamic->d_un.d_val == sizeof(elf_sym));
-			break;
-		// handle lazy relocation table
-		case DT_PLTGOT:
-			object->globalOffsetTable = (void **)(object->baseAddress
-					+ dynamic->d_un.d_ptr);
-			break;
-		case DT_JMPREL:
-			object->lazyRelocTableOffset = dynamic->d_un.d_ptr;
-			break;
-		case DT_PLTRELSZ:
-			object->lazyTableSize = dynamic->d_un.d_val;
-			break;
-		case DT_PLTREL:
-			if(dynamic->d_un.d_val == DT_RELA) {
-				object->lazyExplicitAddend = true;
-			}else{
-				__ensure(dynamic->d_un.d_val == DT_REL);
-				object->lazyExplicitAddend = false;
-			}
-			break;
-		// TODO: Implement this correctly!
-		case DT_SYMBOLIC:
-			object->symbolicResolution = true;
-			break;
-		case DT_BIND_NOW:
-			object->eagerBinding = true;
-			break;
-		case DT_FLAGS: {
-			if(dynamic->d_un.d_val & DF_SYMBOLIC)
-				object->symbolicResolution = true;
-			if(dynamic->d_un.d_val & DF_STATIC_TLS)
-				object->haveStaticTls = true;
-			if(dynamic->d_un.d_val & DF_BIND_NOW)
-				object->eagerBinding = true;
-
-			auto ignored = DF_BIND_NOW | DF_SYMBOLIC | DF_STATIC_TLS;
+  if (!object->dynamic)
+    mlibc::infoLogger() << "ldso: Object '" << object->name
+                        << "' does not have a dynamic section" << frg::endlog;
+  __ensure(object->dynamic);
+
+  // Fix up these offsets to addresses after the loop, since the
+  // addresses depend on the value of DT_STRTAB.
+  frg::optional<ptrdiff_t> runpath_offset;
+  /* If true, ignore the RPATH.  */
+  bool runpath_found = false;
+  frg::optional<ptrdiff_t> soname_offset;
+
+  for (size_t i = 0; object->dynamic[i].d_tag != DT_NULL; i++) {
+    elf_dyn *dynamic = &object->dynamic[i];
+    switch (dynamic->d_tag) {
+    // handle hash table, symbol table and string table
+    case DT_HASH:
+      object->hashStyle = HashStyle::systemV;
+      object->hashTableOffset = dynamic->d_un.d_ptr;
+      break;
+    case DT_GNU_HASH:
+      object->hashStyle = HashStyle::gnu;
+      object->hashTableOffset = dynamic->d_un.d_ptr;
+      break;
+    case DT_STRTAB:
+      object->stringTableOffset = dynamic->d_un.d_ptr;
+      break;
+    case DT_STRSZ:
+      break; // we don't need the size of the string table
+    case DT_SYMTAB:
+      object->symbolTableOffset = dynamic->d_un.d_ptr;
+      break;
+    case DT_SYMENT:
+      __ensure(dynamic->d_un.d_val == sizeof(elf_sym));
+      break;
+    // handle lazy relocation table
+    case DT_PLTGOT:
+      object->globalOffsetTable =
+          (void **)(object->baseAddress + dynamic->d_un.d_ptr);
+      break;
+    case DT_JMPREL:
+      object->lazyRelocTableOffset = dynamic->d_un.d_ptr;
+      break;
+    case DT_PLTRELSZ:
+      object->lazyTableSize = dynamic->d_un.d_val;
+      break;
+    case DT_PLTREL:
+      if (dynamic->d_un.d_val == DT_RELA) {
+        object->lazyExplicitAddend = true;
+      } else {
+        __ensure(dynamic->d_un.d_val == DT_REL);
+        object->lazyExplicitAddend = false;
+      }
+      break;
+    // TODO: Implement this correctly!
+    case DT_SYMBOLIC:
+      object->symbolicResolution = true;
+      break;
+    case DT_BIND_NOW:
+      object->eagerBinding = true;
+      break;
+    case DT_FLAGS: {
+      if (dynamic->d_un.d_val & DF_SYMBOLIC)
+        object->symbolicResolution = true;
+      if (dynamic->d_un.d_val & DF_STATIC_TLS)
+        object->haveStaticTls = true;
+      if (dynamic->d_un.d_val & DF_BIND_NOW)
+        object->eagerBinding = true;
+
+      auto ignored = DF_BIND_NOW | DF_SYMBOLIC | DF_STATIC_TLS;
 #ifdef __riscv
-			// Work around https://sourceware.org/bugzilla/show_bug.cgi?id=24673.
-			ignored |= DF_TEXTREL;
+      // Work around https://sourceware.org/bugzilla/show_bug.cgi?id=24673.
+      ignored |= DF_TEXTREL;
 #else
-			if(dynamic->d_un.d_val & DF_TEXTREL)
-				mlibc::panicLogger() << "\e[31mrtld: DF_TEXTREL is unimplemented" << frg::endlog;
+      if (dynamic->d_un.d_val & DF_TEXTREL)
+        mlibc::panicLogger()
+            << "\e[31mrtld: DF_TEXTREL is unimplemented" << frg::endlog;
 #endif
-			if(dynamic->d_un.d_val & ~ignored)
-				mlibc::infoLogger() << "\e[31mrtld: DT_FLAGS(" << frg::hex_fmt{dynamic->d_un.d_val & ~ignored}
-						<< ") is not implemented correctly!\e[39m"
-						<< frg::endlog;
-		} break;
-		case DT_FLAGS_1:
-			if(dynamic->d_un.d_val & DF_1_NOW)
-				object->eagerBinding = true;
-			// The DF_1_PIE flag is informational only. It is used by e.g file(1).
-			// The DF_1_NODELETE flag has a similar effect to RTLD_NODELETE, both of which we
-			// ignore because we don't implement dlclose().
-			if(dynamic->d_un.d_val & ~(DF_1_NOW | DF_1_PIE | DF_1_NODELETE))
-				mlibc::infoLogger() << "\e[31mrtld: DT_FLAGS_1(" << frg::hex_fmt{dynamic->d_un.d_val}
-						<< ") is not implemented correctly!\e[39m"
-						<< frg::endlog;
-			break;
-		case DT_RPATH:
-			if (runpath_found) {
-				/* Ignore RPATH if RUNPATH was present.  */
-				break;
-			}
-			[[fallthrough]];
-		case DT_RUNPATH:
-			runpath_found = dynamic->d_tag == DT_RUNPATH;
-			runpath_offset = dynamic->d_un.d_val;
-			break;
-		case DT_INIT:
-			if(dynamic->d_un.d_ptr != 0)
-				object->initPtr = (InitFuncPtr)(object->baseAddress + dynamic->d_un.d_ptr);
-			break;
-		case DT_FINI:
-			if(dynamic->d_un.d_ptr != 0)
-				object->finiPtr = (InitFuncPtr)(object->baseAddress + dynamic->d_un.d_ptr);
-			break;
-		case DT_INIT_ARRAY:
-			if(dynamic->d_un.d_ptr != 0)
-				object->initArray = (InitFuncPtr *)(object->baseAddress + dynamic->d_un.d_ptr);
-			break;
-		case DT_FINI_ARRAY:
-			if(dynamic->d_un.d_ptr != 0)
-				object->finiArray = (InitFuncPtr *)(object->baseAddress + dynamic->d_un.d_ptr);
-			break;
-		case DT_INIT_ARRAYSZ:
-			object->initArraySize = dynamic->d_un.d_val;
-			break;
-		case DT_FINI_ARRAYSZ:
-			object->finiArraySize = dynamic->d_un.d_val;
-			break;
-		case DT_PREINIT_ARRAY:
-			if(dynamic->d_un.d_ptr != 0) {
-				// Only the main object is allowed pre-initializers.
-				__ensure(object->isMainObject);
-				object->preInitArray = (InitFuncPtr *)(object->baseAddress + dynamic->d_un.d_ptr);
-			}
-			break;
-		case DT_PREINIT_ARRAYSZ:
-			// Only the main object is allowed pre-initializers.
-			__ensure(object->isMainObject);
-			object->preInitArraySize = dynamic->d_un.d_val;
-			break;
-		case DT_DEBUG:
+      if (dynamic->d_un.d_val & ~ignored)
+        mlibc::infoLogger()
+            << "\e[31mrtld: DT_FLAGS("
+            << frg::hex_fmt{dynamic->d_un.d_val & ~ignored}
+            << ") is not implemented correctly!\e[39m" << frg::endlog;
+    } break;
+    case DT_FLAGS_1:
+      if (dynamic->d_un.d_val & DF_1_NOW)
+        object->eagerBinding = true;
+      // The DF_1_PIE flag is informational only. It is used by e.g file(1).
+      // The DF_1_NODELETE flag has a similar effect to RTLD_NODELETE, both of
+      // which we ignore because we don't implement dlclose().
+      if (dynamic->d_un.d_val & ~(DF_1_NOW | DF_1_PIE | DF_1_NODELETE))
+        mlibc::infoLogger()
+            << "\e[31mrtld: DT_FLAGS_1(" << frg::hex_fmt{dynamic->d_un.d_val}
+            << ") is not implemented correctly!\e[39m" << frg::endlog;
+      break;
+    case DT_RPATH:
+      if (runpath_found) {
+        /* Ignore RPATH if RUNPATH was present.  */
+        break;
+      }
+      [[fallthrough]];
+    case DT_RUNPATH:
+      runpath_found = dynamic->d_tag == DT_RUNPATH;
+      runpath_offset = dynamic->d_un.d_val;
+      break;
+    case DT_INIT:
+      if (dynamic->d_un.d_ptr != 0)
+        object->initPtr =
+            (InitFuncPtr)(object->baseAddress + dynamic->d_un.d_ptr);
+      break;
+    case DT_FINI:
+      if (dynamic->d_un.d_ptr != 0)
+        object->finiPtr =
+            (InitFuncPtr)(object->baseAddress + dynamic->d_un.d_ptr);
+      break;
+    case DT_INIT_ARRAY:
+      if (dynamic->d_un.d_ptr != 0)
+        object->initArray =
+            (InitFuncPtr *)(object->baseAddress + dynamic->d_un.d_ptr);
+      break;
+    case DT_FINI_ARRAY:
+      if (dynamic->d_un.d_ptr != 0)
+        object->finiArray =
+            (InitFuncPtr *)(object->baseAddress + dynamic->d_un.d_ptr);
+      break;
+    case DT_INIT_ARRAYSZ:
+      object->initArraySize = dynamic->d_un.d_val;
+      break;
+    case DT_FINI_ARRAYSZ:
+      object->finiArraySize = dynamic->d_un.d_val;
+      break;
+    case DT_PREINIT_ARRAY:
+      if (dynamic->d_un.d_ptr != 0) {
+        // Only the main object is allowed pre-initializers.
+        __ensure(object->isMainObject);
+        object->preInitArray =
+            (InitFuncPtr *)(object->baseAddress + dynamic->d_un.d_ptr);
+      }
+      break;
+    case DT_PREINIT_ARRAYSZ:
+      // Only the main object is allowed pre-initializers.
+      __ensure(object->isMainObject);
+      object->preInitArraySize = dynamic->d_un.d_val;
+      break;
+    case DT_DEBUG:
 #if ELF_CLASS == ELFCLASS32
-			dynamic->d_un.d_val = reinterpret_cast<Elf32_Word>(&globalDebugInterface);
+      dynamic->d_un.d_val = reinterpret_cast<Elf32_Word>(&globalDebugInterface);
 #elif ELF_CLASS == ELFCLASS64
-			dynamic->d_un.d_val = reinterpret_cast<Elf64_Xword>(&globalDebugInterface);
+      dynamic->d_un.d_val =
+          reinterpret_cast<Elf64_Xword>(&globalDebugInterface);
 #endif
-			break;
-		case DT_SONAME:
-			soname_offset = dynamic->d_un.d_val;
-			break;
-		// handle version information
-		case DT_VERSYM:
-			object->versionTableOffset = dynamic->d_un.d_ptr;
-			break;
-		case DT_VERDEF:
-			object->versionDefinitionTableOffset = dynamic->d_un.d_ptr;
-			break;
-		case DT_VERDEFNUM:
-			object->versionDefinitionCount = dynamic->d_un.d_val;
-			break;
-		case DT_VERNEED:
-			object->versionRequirementTableOffset = dynamic->d_un.d_ptr;
-			break;
-		case DT_VERNEEDNUM:
-			object->versionRequirementCount = dynamic->d_un.d_val;
-			break;
-		// ignore unimportant tags
-		case DT_NEEDED: // we handle this later
-		case DT_RELA: case DT_RELASZ: case DT_RELAENT: case DT_RELACOUNT:
-		case DT_REL: case DT_RELSZ: case DT_RELENT: case DT_RELCOUNT:
-		case DT_RELR: case DT_RELRSZ: case DT_RELRENT:
+      break;
+    case DT_SONAME:
+      soname_offset = dynamic->d_un.d_val;
+      break;
+    // handle version information
+    case DT_VERSYM:
+      object->versionTableOffset = dynamic->d_un.d_ptr;
+      break;
+    case DT_VERDEF:
+      object->versionDefinitionTableOffset = dynamic->d_un.d_ptr;
+      break;
+    case DT_VERDEFNUM:
+      object->versionDefinitionCount = dynamic->d_un.d_val;
+      break;
+    case DT_VERNEED:
+      object->versionRequirementTableOffset = dynamic->d_un.d_ptr;
+      break;
+    case DT_VERNEEDNUM:
+      object->versionRequirementCount = dynamic->d_un.d_val;
+      break;
+    // ignore unimportant tags
+    case DT_NEEDED: // we handle this later
+    case DT_RELA:
+    case DT_RELASZ:
+    case DT_RELAENT:
+    case DT_RELACOUNT:
+    case DT_REL:
+    case DT_RELSZ:
+    case DT_RELENT:
+    case DT_RELCOUNT:
+    case DT_RELR:
+    case DT_RELRSZ:
+    case DT_RELRENT:
 #ifdef __riscv
-		case DT_TEXTREL: // Work around https://sourceware.org/bugzilla/show_bug.cgi?id=24673.
+    case DT_TEXTREL: // Work around
+                     // https://sourceware.org/bugzilla/show_bug.cgi?id=24673.
 #endif
-			break;
-		case DT_TLSDESC_PLT: case DT_TLSDESC_GOT:
-			break;
-		default:
-			// Ignore unknown entries in the os-specific area as we don't use them.
-			if(dynamic->d_tag < DT_LOOS || dynamic->d_tag > DT_HIOS) {
-				mlibc::panicLogger() << "Unexpected dynamic entry "
-					<< (void *)dynamic->d_tag << " in object" << frg::endlog;
-			}
-		}
-	}
-
-	if(runpath_offset) {
-		object->runPath = reinterpret_cast<const char *>(object->baseAddress
-				+ object->stringTableOffset + *runpath_offset);
-	}
-	if(soname_offset) {
-		object->soName = reinterpret_cast<const char *>(object->baseAddress
-				+ object->stringTableOffset + *soname_offset);
-	}
+      break;
+    case DT_TLSDESC_PLT:
+    case DT_TLSDESC_GOT:
+      break;
+    default:
+      // Ignore unknown entries in the os-specific area as we don't use them.
+      if (dynamic->d_tag < DT_LOOS || dynamic->d_tag > DT_HIOS) {
+        mlibc::panicLogger()
+            << "Unexpected dynamic entry " << (void *)dynamic->d_tag
+            << " in object" << frg::endlog;
+      }
+    }
+  }
+
+  if (runpath_offset) {
+    object->runPath = reinterpret_cast<const char *>(
+        object->baseAddress + object->stringTableOffset + *runpath_offset);
+  }
+  if (soname_offset) {
+    object->soName = reinterpret_cast<const char *>(
+        object->baseAddress + object->stringTableOffset + *soname_offset);
+  }
 }
 
 void ObjectRepository::_parseVerdef(SharedObject *object) {
-	if(!object->versionDefinitionTableOffset) {
-		if(verbose)
-			mlibc::infoLogger()
-				<< "mlibc: Object " << object->name
-				<< " defines no versions" << frg::endlog;
-		return;
-	}
-
-	if(verbose)
-		mlibc::infoLogger()
-			<< "mlibc: Object " << object->name
-			<< " defines " << object->versionDefinitionCount
-			<< " version(s)" << frg::endlog;
-
-	uintptr_t address =
-		object->baseAddress
-		+ object->versionDefinitionTableOffset;
-
-	for(size_t i = 0; i < object->versionDefinitionCount; i++) {
-		elf_verdef def;
-		memcpy(&def, reinterpret_cast<void *>(address), sizeof(elf_verdef));
-
-		// Required by spec.
-		__ensure(def.vd_version == 1);
-		__ensure(def.vd_cnt >= 1);
-		__ensure(!(def.vd_flags & ~(VER_FLG_BASE | VER_FLG_WEAK)));
-
-		// NOTE(qookie): glibc also ignores any additional Verdaux entries after the
-		// first one.
-		elf_verdaux aux;
-		memcpy(&aux, reinterpret_cast<void *>(address + def.vd_aux), sizeof(elf_verdaux));
-
-		const char *name =
-			reinterpret_cast<const char *>(
-				object->baseAddress
-				+ object->stringTableOffset + aux.vda_name);
-
-		if(verbose)
-			mlibc::infoLogger()
-				<< "mlibc: Object " << object->name
-				<< " defines version " << name
-				<< " (index " << def.vd_ndx << ")"
-				<< frg::endlog;
-
-		if(!(def.vd_flags & VER_FLG_BASE)) {
-			SymbolVersion ver{name, def.vd_hash};
-			object->definedVersions.push(ver);
-			object->knownVersions.insert(def.vd_ndx, ver);
-		}
-
-		address += def.vd_next;
-	}
+  if (!object->versionDefinitionTableOffset) {
+    if (verbose)
+      mlibc::infoLogger() << "mlibc: Object " << object->name
+                          << " defines no versions" << frg::endlog;
+    return;
+  }
+
+  if (verbose)
+    mlibc::infoLogger() << "mlibc: Object " << object->name << " defines "
+                        << object->versionDefinitionCount << " version(s)"
+                        << frg::endlog;
+
+  uintptr_t address =
+      object->baseAddress + object->versionDefinitionTableOffset;
+
+  for (size_t i = 0; i < object->versionDefinitionCount; i++) {
+    elf_verdef def;
+    memcpy(&def, reinterpret_cast<void *>(address), sizeof(elf_verdef));
+
+    // Required by spec.
+    __ensure(def.vd_version == 1);
+    __ensure(def.vd_cnt >= 1);
+    __ensure(!(def.vd_flags & ~(VER_FLG_BASE | VER_FLG_WEAK)));
+
+    // NOTE(qookie): glibc also ignores any additional Verdaux entries after the
+    // first one.
+    elf_verdaux aux;
+    memcpy(&aux, reinterpret_cast<void *>(address + def.vd_aux),
+           sizeof(elf_verdaux));
+
+    const char *name = reinterpret_cast<const char *>(
+        object->baseAddress + object->stringTableOffset + aux.vda_name);
+
+    if (verbose)
+      mlibc::infoLogger() << "mlibc: Object " << object->name
+                          << " defines version " << name << " (index "
+                          << def.vd_ndx << ")" << frg::endlog;
+
+    if (!(def.vd_flags & VER_FLG_BASE)) {
+      SymbolVersion ver{name, def.vd_hash};
+      object->definedVersions.push(ver);
+      object->knownVersions.insert(def.vd_ndx, ver);
+    }
+
+    address += def.vd_next;
+  }
 }
 
 void ObjectRepository::_parseVerneed(SharedObject *object) {
-	if(!object->versionRequirementTableOffset) {
-		if(verbose)
-			mlibc::infoLogger() << "mlibc: Object " << object->name << " requires no versions" << frg::endlog;
-		return;
-	}
-
-	if(verbose)
-		mlibc::infoLogger()
-			<< "mlibc: Object " << object->name
-			<< " requires " << object->versionRequirementCount
-			<< " version(s)" << frg::endlog;
-
-	uintptr_t address =
-		object->baseAddress
-		+ object->versionRequirementTableOffset;
-
-	for(size_t i = 0; i < object->versionRequirementCount; i++) {
-		elf_verneed need;
-		memcpy(&need, reinterpret_cast<void *>(address), sizeof(elf_verneed));
-
-		// Required by spec.
-		__ensure(need.vn_version == 1);
-
-		frg::string_view file =
-			reinterpret_cast<const char *>(
-				object->baseAddress
-				+ object->stringTableOffset + need.vn_file);
-
-		// Figure out the target object from file
-		SharedObject *target = nullptr;
-		for(auto dep : object->dependencies) {
-			if(verbose)
-				mlibc::infoLogger()
-					<< "mlibc: Trying " << dep->name << " (SONAME: "
-					<< dep->soName << ") to satisfy " << file << frg::endlog;
-			if(dep->name == file || (dep->soName && dep->soName == file)) {
-				target = dep;
-				break;
-			}
-		}
-		if(!target)
-			mlibc::panicLogger()
-				<< "mlibc: No object named \""
-				<< file
-				<< "\" found for VERNEED entry of object "
-				<< object->name << frg::endlog;
-
-		if(verbose)
-			mlibc::infoLogger()
-				<< "mlibc: Object " << object->name
-				<< " requires " << need.vn_cnt
-				<< " version(s) from DSO "
-				<< file << frg::endlog;
-
-		uintptr_t auxAddr = address + need.vn_aux;
-		for(size_t j = 0; j < need.vn_cnt; j++) {
-			elf_vernaux aux;
-			memcpy(&aux, reinterpret_cast<void *>(auxAddr), sizeof(elf_vernaux));
-
-			// TODO(qookie): Handle weak versions.
-			__ensure(!aux.vna_flags);
-
-			const char *name =
-				reinterpret_cast<const char *>(
-					object->baseAddress
-					+ object->stringTableOffset + aux.vna_name);
-
-			if(verbose)
-				mlibc::infoLogger()
-					<< "mlibc:   Object " << object->name
-					<< " requires version " << name
-					<< " (index " << aux.vna_other
-					<< ") from DSO " << file
-					<< frg::endlog;
-
-			frg::optional<SymbolVersion> ver;
-			for(auto &def : target->definedVersions) {
-				if(def.hash() != aux.vna_hash) continue;
-				if(def.name() == name) {
-					ver = def;
-					break;
-				}
-			}
-
-			if(!ver)
-				mlibc::panicLogger()
-					<< "mlibc: Object " << target->name
-					<< " does not define version \""
-					<< name << "\" needed by object "
-					<< object->name << frg::endlog;
-
-			bool isDefault = !(aux.vna_other & 0x8000);
-			// Bit 15 indicates whether the static linker should ignore this version.
-			object->knownVersions.insert(aux.vna_other & 0x7FFF, isDefault ? ver->makeDefault() : *ver);
-
-			auxAddr += aux.vna_next;
-		}
-		address += need.vn_next;
-	}
+  if (!object->versionRequirementTableOffset) {
+    if (verbose)
+      mlibc::infoLogger() << "mlibc: Object " << object->name
+                          << " requires no versions" << frg::endlog;
+    return;
+  }
+
+  if (verbose)
+    mlibc::infoLogger() << "mlibc: Object " << object->name << " requires "
+                        << object->versionRequirementCount << " version(s)"
+                        << frg::endlog;
+
+  uintptr_t address =
+      object->baseAddress + object->versionRequirementTableOffset;
+
+  for (size_t i = 0; i < object->versionRequirementCount; i++) {
+    elf_verneed need;
+    memcpy(&need, reinterpret_cast<void *>(address), sizeof(elf_verneed));
+
+    // Required by spec.
+    __ensure(need.vn_version == 1);
+
+    frg::string_view file = reinterpret_cast<const char *>(
+        object->baseAddress + object->stringTableOffset + need.vn_file);
+
+    // Figure out the target object from file
+    SharedObject *target = nullptr;
+    for (auto dep : object->dependencies) {
+      if (verbose)
+        mlibc::infoLogger()
+            << "mlibc: Trying " << dep->name << " (SONAME: " << dep->soName
+            << ") to satisfy " << file << frg::endlog;
+      if (dep->name == file || (dep->soName && dep->soName == file)) {
+        target = dep;
+        break;
+      }
+    }
+    if (!target)
+      mlibc::panicLogger() << "mlibc: No object named \"" << file
+                           << "\" found for VERNEED entry of object "
+                           << object->name << frg::endlog;
+
+    if (verbose)
+      mlibc::infoLogger() << "mlibc: Object " << object->name << " requires "
+                          << need.vn_cnt << " version(s) from DSO " << file
+                          << frg::endlog;
+
+    uintptr_t auxAddr = address + need.vn_aux;
+    for (size_t j = 0; j < need.vn_cnt; j++) {
+      elf_vernaux aux;
+      memcpy(&aux, reinterpret_cast<void *>(auxAddr), sizeof(elf_vernaux));
+
+      // TODO(qookie): Handle weak versions.
+      __ensure(!aux.vna_flags);
+
+      const char *name = reinterpret_cast<const char *>(
+          object->baseAddress + object->stringTableOffset + aux.vna_name);
+
+      if (verbose)
+        mlibc::infoLogger()
+            << "mlibc:   Object " << object->name << " requires version "
+            << name << " (index " << aux.vna_other << ") from DSO " << file
+            << frg::endlog;
+
+      frg::optional<SymbolVersion> ver;
+      for (auto &def : target->definedVersions) {
+        if (def.hash() != aux.vna_hash)
+          continue;
+        if (def.name() == name) {
+          ver = def;
+          break;
+        }
+      }
+
+      if (!ver)
+        mlibc::panicLogger()
+            << "mlibc: Object " << target->name << " does not define version \""
+            << name << "\" needed by object " << object->name << frg::endlog;
+
+      bool isDefault = !(aux.vna_other & 0x8000);
+      // Bit 15 indicates whether the static linker should ignore this version.
+      object->knownVersions.insert(aux.vna_other & 0x7FFF,
+                                   isDefault ? ver->makeDefault() : *ver);
+
+      auxAddr += aux.vna_next;
+    }
+    address += need.vn_next;
+  }
 }
 
 void ObjectRepository::_discoverDependencies(SharedObject *object,
-		Scope *localScope, uint64_t rts) {
-	if(object->isMainObject) {
-		for(auto preload : *preloads) {
-			frg::expected<LinkerError, SharedObject *> libraryResult;
-			if (preload.find_first('/') == size_t(-1)) {
-				libraryResult = requestObjectWithName(preload, object, globalScope.get(), false, 1);
-			} else {
-				libraryResult = requestObjectAtPath(preload, globalScope.get(), false, 1);
-			}
-			if(!libraryResult)
-				mlibc::panicLogger() << "rtld: Could not load preload " << preload << frg::endlog;
-
-			if(verbose)
-				mlibc::infoLogger() << "rtld: Preloading " << preload << frg::endlog;
-
-			auto library = libraryResult.value();
-			object->dependencies.push_back(library);
-			if (library->wasVisited)
-				continue;
-			library->wasVisited = true;
-			dependencyQueue.push_back(library);
-		}
-	}
-
-	// Load required dynamic libraries.
-	for(size_t i = 0; object->dynamic[i].d_tag != DT_NULL; i++) {
-		elf_dyn *dynamic = &object->dynamic[i];
-		if(dynamic->d_tag != DT_NEEDED)
-			continue;
-
-		const char *library_str = (const char *)(object->baseAddress
-				+ object->stringTableOffset + dynamic->d_un.d_val);
-
-		auto libraryResult = requestObjectWithName(frg::string_view{library_str},
-				object, localScope, false, rts);
-		if(!libraryResult)
-			mlibc::panicLogger() << "Could not satisfy dependency " << library_str << frg::endlog;
-
-		auto library = libraryResult.value();
-		object->dependencies.push(library);
-		if (library->wasVisited)
-			continue;
-		library->wasVisited = true;
-		dependencyQueue.push_back(library);
-	}
+                                             Scope *localScope, uint64_t rts) {
+  if (object->isMainObject) {
+    for (auto preload : *preloads) {
+      frg::expected<LinkerError, SharedObject *> libraryResult;
+      if (preload.find_first('/') == size_t(-1)) {
+        libraryResult =
+            requestObjectWithName(preload, object, globalScope.get(), false, 1);
+      } else {
+        libraryResult =
+            requestObjectAtPath(preload, globalScope.get(), false, 1);
+      }
+      if (!libraryResult)
+        mlibc::panicLogger()
+            << "rtld: Could not load preload " << preload << frg::endlog;
+
+      if (verbose)
+        mlibc::infoLogger() << "rtld: Preloading " << preload << frg::endlog;
+
+      auto library = libraryResult.value();
+      object->dependencies.push_back(library);
+      if (library->wasVisited)
+        continue;
+      library->wasVisited = true;
+      dependencyQueue.push_back(library);
+    }
+  }
+
+  // Load required dynamic libraries.
+  for (size_t i = 0; object->dynamic[i].d_tag != DT_NULL; i++) {
+    elf_dyn *dynamic = &object->dynamic[i];
+    if (dynamic->d_tag != DT_NEEDED)
+      continue;
+
+    const char *library_str =
+        (const char *)(object->baseAddress + object->stringTableOffset +
+                       dynamic->d_un.d_val);
+
+    auto libraryResult = requestObjectWithName(frg::string_view{library_str},
+                                               object, localScope, false, rts);
+    if (!libraryResult)
+      mlibc::panicLogger() << "Could not satisfy dependency " << library_str
+                           << frg::endlog;
+
+    auto library = libraryResult.value();
+    object->dependencies.push(library);
+    if (library->wasVisited)
+      continue;
+    library->wasVisited = true;
+    dependencyQueue.push_back(library);
+  }
 }
 
 void ObjectRepository::_addLoadedObject(SharedObject *object) {
-	_nameMap.insert(object->name, object);
-	loadedObjects.push_back(object);
+  _nameMap.insert(object->name, object);
+  loadedObjects.push_back(object);
 }
 
 // --------------------------------------------------------
@@ -1034,220 +1059,216 @@ void ObjectRepository::_addLoadedObject(SharedObject *object) {
 // --------------------------------------------------------
 
 SharedObject::SharedObject(const char *name, frg::string<MemoryAllocator> path,
-	bool is_main_object, Scope *local_scope, uint64_t object_rts)
-		: name(name, getAllocator()), path(std::move(path)),
-		interpreterPath(getAllocator()), soName(nullptr),
-		isMainObject(is_main_object), objectRts(object_rts), inLinkMap(false),
-		baseAddress(0), localScope(local_scope), dynamic(nullptr),
-		globalOffsetTable(nullptr), entry(nullptr), tlsSegmentSize(0),
-		tlsAlignment(0), tlsImageSize(0), tlsImagePtr(nullptr),
-		tlsInitialized(false), hashTableOffset(0), symbolTableOffset(0),
-		stringTableOffset(0),
-		knownVersions({}, getAllocator()), definedVersions(getAllocator()),
-		lazyRelocTableOffset(0), lazyTableSize(0),
-		lazyExplicitAddend(false), symbolicResolution(false),
-		eagerBinding(false), haveStaticTls(false),
-		dependencies(getAllocator()), tlsModel(TlsModel::null),
-		tlsOffset(0), globalRts(0), wasLinked(false),
-		scheduledForInit(false), onInitStack(false),
-		wasInitialized(false) { }
+                           bool is_main_object, Scope *local_scope,
+                           uint64_t object_rts)
+    : name(name, getAllocator()), path(std::move(path)),
+      interpreterPath(getAllocator()), soName(nullptr),
+      isMainObject(is_main_object), objectRts(object_rts), inLinkMap(false),
+      baseAddress(0), localScope(local_scope), dynamic(nullptr),
+      globalOffsetTable(nullptr), entry(nullptr), tlsSegmentSize(0),
+      tlsAlignment(0), tlsImageSize(0), tlsImagePtr(nullptr),
+      tlsInitialized(false), hashTableOffset(0), symbolTableOffset(0),
+      stringTableOffset(0), knownVersions({}, getAllocator()),
+      definedVersions(getAllocator()), lazyRelocTableOffset(0),
+      lazyTableSize(0), lazyExplicitAddend(false), symbolicResolution(false),
+      eagerBinding(false), haveStaticTls(false), dependencies(getAllocator()),
+      tlsModel(TlsModel::null), tlsOffset(0), globalRts(0), wasLinked(false),
+      scheduledForInit(false), onInitStack(false), wasInitialized(false) {}
 
 SharedObject::SharedObject(const char *name, const char *path,
-	bool is_main_object, Scope *localScope, uint64_t object_rts)
-		: SharedObject(name,
-			frg::string<MemoryAllocator> { path, getAllocator() },
-			is_main_object, localScope, object_rts) {}
-
-frg::tuple<ObjectSymbol, SymbolVersion> SharedObject::getSymbolByIndex(size_t index) {
-	SymbolVersion ver{1}; // If we don't have any version information, treat all symbols as global.
-	ObjectSymbol sym{
-		this,
-		reinterpret_cast<elf_sym *>(
-			baseAddress
-			+ symbolTableOffset
-			+ index * sizeof(elf_sym))};
-
-	if(versionTableOffset) {
-		// Pull out the VERSYM entry for this symbol
-		elf_version verIdx;
-		memcpy(
-			&verIdx,
-			reinterpret_cast<void *>(
-				baseAddress
-				+ versionTableOffset
-				+ index * sizeof(elf_version)),
-			sizeof(elf_version)
-		);
-
-		// Bit 15 indicates that this version is not the default one.
-		bool isDefault = !(verIdx & 0x8000);
-		verIdx &= 0x7FFF;
-
-		// 0 and 1 are special, 0 is local, 1 is global (not in VERDEF/VERNEED)
-		if(verIdx != 0 && verIdx != 1) {
-			auto maybeVer = knownVersions.find(verIdx);
-			if(maybeVer == knownVersions.end())
-				mlibc::panicLogger()
-					<< "mlibc: Symbol " << sym.getString()
-					<< " of object " << name
-					<< " has invalid version index " << verIdx
-					<< frg::endlog;
-
-			ver = maybeVer->get<1>();
-		} else {
-			ver = SymbolVersion{verIdx};
-		}
-
-		if(isDefault)
-			ver = ver.makeDefault();
-
-		if(logSymbolVersions)
-			mlibc::infoLogger()
-				<< "mlibc: Symbol " << sym.getString()
-				<< " of object " << name
-				<< " has version " << ver.name()
-				<< " and " << (ver.isDefault() ? "is" : "isn't")
-				<< " the default version"
-				<< frg::endlog;
-	} else {
-		// If we have no version information, the only symbol we've got is the default.
-		ver = ver.makeDefault();
-	}
-
-	return {sym, ver};
+                           bool is_main_object, Scope *localScope,
+                           uint64_t object_rts)
+    : SharedObject(name, frg::string<MemoryAllocator>{path, getAllocator()},
+                   is_main_object, localScope, object_rts) {}
+
+frg::tuple<ObjectSymbol, SymbolVersion>
+SharedObject::getSymbolByIndex(size_t index) {
+  SymbolVersion ver{1}; // If we don't have any version information, treat all
+                        // symbols as global.
+  ObjectSymbol sym{this,
+                   reinterpret_cast<elf_sym *>(baseAddress + symbolTableOffset +
+                                               index * sizeof(elf_sym))};
+
+  if (versionTableOffset) {
+    // Pull out the VERSYM entry for this symbol
+    elf_version verIdx;
+    memcpy(&verIdx,
+           reinterpret_cast<void *>(baseAddress + versionTableOffset +
+                                    index * sizeof(elf_version)),
+           sizeof(elf_version));
+
+    // Bit 15 indicates that this version is not the default one.
+    bool isDefault = !(verIdx & 0x8000);
+    verIdx &= 0x7FFF;
+
+    // 0 and 1 are special, 0 is local, 1 is global (not in VERDEF/VERNEED)
+    if (verIdx != 0 && verIdx != 1) {
+      auto maybeVer = knownVersions.find(verIdx);
+      if (maybeVer == knownVersions.end())
+        mlibc::panicLogger()
+            << "mlibc: Symbol " << sym.getString() << " of object " << name
+            << " has invalid version index " << verIdx << frg::endlog;
+
+      ver = maybeVer->get<1>();
+    } else {
+      ver = SymbolVersion{verIdx};
+    }
+
+    if (isDefault)
+      ver = ver.makeDefault();
+
+    if (logSymbolVersions)
+      mlibc::infoLogger() << "mlibc: Symbol " << sym.getString()
+                          << " of object " << name << " has version "
+                          << ver.name() << " and "
+                          << (ver.isDefault() ? "is" : "isn't")
+                          << " the default version" << frg::endlog;
+  } else {
+    // If we have no version information, the only symbol we've got is the
+    // default.
+    ver = ver.makeDefault();
+  }
+
+  return {sym, ver};
 }
 
 void processLateRelocation(Relocation rel) {
-	// resolve the symbol if there is a symbol
-	frg::optional<ObjectSymbol> p;
-	if(rel.symbol_index()) {
-		auto [sym, ver] = rel.object()->getSymbolByIndex(rel.symbol_index());
-
-		p = Scope::resolveGlobalOrLocal(*globalScope, rel.object()->localScope,
-				sym.getString(), rel.object()->objectRts, Scope::resolveCopy, ver);
-	}
-
-	switch(rel.type()) {
-	case R_COPY:
-		__ensure(p);
-		memcpy(rel.destination(), (void *)p->virtualAddress(), p->symbol()->st_size);
-		break;
-
-// TODO: R_IRELATIVE also exists on other architectures but will likely need a different implementation.
+  // resolve the symbol if there is a symbol
+  frg::optional<ObjectSymbol> p;
+  if (rel.symbol_index()) {
+    auto [sym, ver] = rel.object()->getSymbolByIndex(rel.symbol_index());
+
+    p = Scope::resolveGlobalOrLocal(*globalScope, rel.object()->localScope,
+                                    sym.getString(), rel.object()->objectRts,
+                                    Scope::resolveCopy, ver);
+  }
+
+  switch (rel.type()) {
+  case R_COPY:
+    __ensure(p);
+    memcpy(rel.destination(), (void *)p->virtualAddress(),
+           p->symbol()->st_size);
+    break;
+
+// TODO: R_IRELATIVE also exists on other architectures but will likely need a
+// different implementation.
 #if defined(__x86_64__) || defined(__i386__)
-	case R_IRELATIVE: {
-		uintptr_t addr = rel.object()->baseAddress + rel.addend_rel();
-		auto* fn = reinterpret_cast<uintptr_t (*)()>(addr);
-		rel.relocate(fn());
-	} break;
+  case R_IRELATIVE: {
+    uintptr_t addr = rel.object()->baseAddress + rel.addend_rel();
+    auto *fn = reinterpret_cast<uintptr_t (*)()>(addr);
+    rel.relocate(fn());
+  } break;
 #elif defined(__aarch64__)
-	case R_IRELATIVE: {
-		uintptr_t addr = rel.object()->baseAddress + rel.addend_rel();
-		auto* fn = reinterpret_cast<uintptr_t (*)(uint64_t)>(addr);
-		// TODO: the function should get passed AT_HWCAP value.
-		rel.relocate(fn(0));
-	} break;
+  case R_IRELATIVE: {
+    uintptr_t addr = rel.object()->baseAddress + rel.addend_rel();
+    auto *fn = reinterpret_cast<uintptr_t (*)(uint64_t)>(addr);
+    // TODO: the function should get passed AT_HWCAP value.
+    rel.relocate(fn(0));
+  } break;
 #endif
 
-	default:
-		break;
-	}
+  default:
+    break;
+  }
 }
 
 void processLateRelocations(SharedObject *object) {
-	frg::optional<uintptr_t> rel_offset;
-	frg::optional<size_t> rel_length;
-
-	frg::optional<uintptr_t> rela_offset;
-	frg::optional<size_t> rela_length;
-
-	for(size_t i = 0; object->dynamic[i].d_tag != DT_NULL; i++) {
-		elf_dyn *dynamic = &object->dynamic[i];
-
-		switch(dynamic->d_tag) {
-		case DT_REL:
-			rel_offset = dynamic->d_un.d_ptr;
-			break;
-		case DT_RELSZ:
-			rel_length = dynamic->d_un.d_val;
-			break;
-		case DT_RELENT:
-			__ensure(dynamic->d_un.d_val == sizeof(elf_rel));
-			break;
-		case DT_RELA:
-			rela_offset = dynamic->d_un.d_ptr;
-			break;
-		case DT_RELASZ:
-			rela_length = dynamic->d_un.d_val;
-			break;
-		case DT_RELAENT:
-			__ensure(dynamic->d_un.d_val == sizeof(elf_rela));
-			break;
-		}
-	}
-
-	if(rela_offset && rela_length) {
-		for(size_t offset = 0; offset < *rela_length; offset += sizeof(elf_rela)) {
-			auto reloc = (elf_rela *)(object->baseAddress + *rela_offset + offset);
-			auto r = Relocation(object, reloc);
-			processLateRelocation(r);
-		}
-	} else if(rel_offset && rel_length) {
-		for(size_t offset = 0; offset < *rel_length; offset += sizeof(elf_rel)) {
-			auto reloc = (elf_rel *)(object->baseAddress + *rel_offset + offset);
-			auto r = Relocation(object, reloc);
-			processLateRelocation(r);
-		}
-	}else{
-		__ensure(!rela_offset && !rela_length);
-		__ensure(!rel_offset && !rel_length);
-	}
+  frg::optional<uintptr_t> rel_offset;
+  frg::optional<size_t> rel_length;
+
+  frg::optional<uintptr_t> rela_offset;
+  frg::optional<size_t> rela_length;
+
+  for (size_t i = 0; object->dynamic[i].d_tag != DT_NULL; i++) {
+    elf_dyn *dynamic = &object->dynamic[i];
+
+    switch (dynamic->d_tag) {
+    case DT_REL:
+      rel_offset = dynamic->d_un.d_ptr;
+      break;
+    case DT_RELSZ:
+      rel_length = dynamic->d_un.d_val;
+      break;
+    case DT_RELENT:
+      __ensure(dynamic->d_un.d_val == sizeof(elf_rel));
+      break;
+    case DT_RELA:
+      rela_offset = dynamic->d_un.d_ptr;
+      break;
+    case DT_RELASZ:
+      rela_length = dynamic->d_un.d_val;
+      break;
+    case DT_RELAENT:
+      __ensure(dynamic->d_un.d_val == sizeof(elf_rela));
+      break;
+    }
+  }
+
+  if (rela_offset && rela_length) {
+    for (size_t offset = 0; offset < *rela_length; offset += sizeof(elf_rela)) {
+      auto reloc = (elf_rela *)(object->baseAddress + *rela_offset + offset);
+      auto r = Relocation(object, reloc);
+      processLateRelocation(r);
+    }
+  } else if (rel_offset && rel_length) {
+    for (size_t offset = 0; offset < *rel_length; offset += sizeof(elf_rel)) {
+      auto reloc = (elf_rel *)(object->baseAddress + *rel_offset + offset);
+      auto r = Relocation(object, reloc);
+      processLateRelocation(r);
+    }
+  } else {
+    __ensure(!rela_offset && !rela_length);
+    __ensure(!rel_offset && !rel_length);
+  }
 }
 
 void doInitialize(SharedObject *object) {
-	__ensure(object->wasLinked);
-	__ensure(!object->wasInitialized);
-
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Initialize " << object->name << frg::endlog;
-
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Running DT_INIT function" << frg::endlog;
-	if(object->initPtr != nullptr)
-		object->initPtr();
-
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Running DT_INIT_ARRAY functions" << frg::endlog;
-	__ensure((object->initArraySize % sizeof(InitFuncPtr)) == 0);
-	for(size_t i = 0; i < object->initArraySize / sizeof(InitFuncPtr); i++)
-		object->initArray[i]();
-
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Object initialization complete" << frg::endlog;
-	object->wasInitialized = true;
+  __ensure(object->wasLinked);
+  __ensure(!object->wasInitialized);
+
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Initialize " << object->name << frg::endlog;
+
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Running DT_INIT function" << frg::endlog;
+  if (object->initPtr != nullptr)
+    object->initPtr();
+
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Running DT_INIT_ARRAY functions"
+                        << frg::endlog;
+  __ensure((object->initArraySize % sizeof(InitFuncPtr)) == 0);
+  for (size_t i = 0; i < object->initArraySize / sizeof(InitFuncPtr); i++)
+    object->initArray[i]();
+
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Object initialization complete"
+                        << frg::endlog;
+  object->wasInitialized = true;
 }
 
 void doDestruct(SharedObject *object) {
-	if(!object->wasInitialized || object->wasDestroyed)
-		return;
-
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Destruct " << object->name << frg::endlog;
-
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Running DT_FINI_ARRAY functions" << frg::endlog;
-	__ensure((object->finiArraySize % sizeof(InitFuncPtr)) == 0);
-	for(size_t i = object->finiArraySize / sizeof(InitFuncPtr); i > 0; i--)
-		object->finiArray[i - 1]();
-
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Running DT_FINI function" << frg::endlog;
-	if(object->finiPtr != nullptr)
-		object->finiPtr();
-
-	if(verbose)
-		mlibc::infoLogger() << "rtld: Object destruction complete" << frg::endlog;
-	object->wasDestroyed = true;
+  if (!object->wasInitialized || object->wasDestroyed)
+    return;
+
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Destruct " << object->name << frg::endlog;
+
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Running DT_FINI_ARRAY functions"
+                        << frg::endlog;
+  __ensure((object->finiArraySize % sizeof(InitFuncPtr)) == 0);
+  for (size_t i = object->finiArraySize / sizeof(InitFuncPtr); i > 0; i--)
+    object->finiArray[i - 1]();
+
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Running DT_FINI function" << frg::endlog;
+  if (object->finiPtr != nullptr)
+    object->finiPtr();
+
+  if (verbose)
+    mlibc::infoLogger() << "rtld: Object destruction complete" << frg::endlog;
+  object->wasDestroyed = true;
 }
 
 // --------------------------------------------------------
@@ -1255,146 +1276,166 @@ void doDestruct(SharedObject *object) {
 // --------------------------------------------------------
 
 RuntimeTlsMap::RuntimeTlsMap()
-: initialPtr{0}, initialLimit{0}, indices{getAllocator()} { }
-
-void initTlsObjects(Tcb *tcb, const frg::vector<SharedObject *, MemoryAllocator> &objects, bool checkInitialized) {
-	// Initialize TLS segments that follow the static model.
-	for(auto object : objects) {
-		if(object->tlsModel == TlsModel::initial) {
-			if(checkInitialized && object->tlsInitialized)
-				continue;
-
-			char *tcb_ptr = reinterpret_cast<char *>(tcb);
-			auto tls_ptr = tcb_ptr + object->tlsOffset;
-
-			if constexpr (tlsAboveTp) {
-				tls_ptr += sizeof(Tcb);
-			}
-
-			memset(tls_ptr, 0, object->tlsSegmentSize);
-			memcpy(tls_ptr, object->tlsImagePtr, object->tlsImageSize);
-
-			if (verbose) {
-				mlibc::infoLogger() << "rtld: wrote tls image at " << (void *)tls_ptr
-						<< ", size = 0x" << frg::hex_fmt{object->tlsSegmentSize} << frg::endlog;
-			}
-
-			if (checkInitialized)
-				object->tlsInitialized = true;
-		}
-	}
+    : initialPtr{0}, initialLimit{0}, indices{getAllocator()} {}
+
+void initTlsObjects(Tcb *tcb,
+                    const frg::vector<SharedObject *, MemoryAllocator> &objects,
+                    bool checkInitialized) {
+  // Initialize TLS segments that follow the static model.
+  for (auto object : objects) {
+    if (object->tlsModel == TlsModel::initial) {
+      if (checkInitialized && object->tlsInitialized)
+        continue;
+
+      char *tcb_ptr = reinterpret_cast<char *>(tcb);
+      auto tls_ptr = tcb_ptr + object->tlsOffset;
+
+      if constexpr (tlsAboveTp) {
+        tls_ptr += sizeof(Tcb);
+      }
+
+      memset(tls_ptr, 0, object->tlsSegmentSize);
+      memcpy(tls_ptr, object->tlsImagePtr, object->tlsImageSize);
+
+      if (verbose) {
+        mlibc::infoLogger()
+            << "rtld: wrote tls image at " << (void *)tls_ptr << ", size = 0x"
+            << frg::hex_fmt{object->tlsSegmentSize} << frg::endlog;
+      }
+
+      if (checkInitialized)
+        object->tlsInitialized = true;
+    }
+  }
 }
 
 Tcb *allocateTcb() {
-	size_t tlsInitialSize = runtimeTlsMap->initialLimit;
-
-	// To make sure that both the TCB and TLS data are sufficiently aligned, allocate
-	// slightly more than necessary and adjust alignment afterwards.
-	size_t alignOverhead = frg::max(alignof(Tcb), tlsMaxAlignment);
-	size_t allocSize = tlsInitialSize + sizeof(Tcb) + alignOverhead;
-	auto allocation = reinterpret_cast<uintptr_t>(getAllocator().allocate(allocSize));
-	memset(reinterpret_cast<void *>(allocation), 0, allocSize);
-
-	uintptr_t tlsAddress, tcbAddress;
-	if constexpr (tlsAboveTp) {
-		// Here we must satisfy two requirements of the TCB and the TLS data:
-		//   1. One should follow the other immediately in memory. We do this so that
-		//      we can simply add or subtract sizeof(Tcb) to obtain the address of the other.
-		//   2. Both should be sufficiently aligned.
-		// To do this, we will fix whichever address has stricter alignment requirements, and
-		// derive the other from it.
-		if (tlsMaxAlignment > alignof(Tcb)) {
-			tlsAddress = alignUp(allocation + sizeof(Tcb), tlsMaxAlignment);
-			tcbAddress = tlsAddress - sizeof(Tcb);
-		} else {
-			tcbAddress = alignUp(allocation, alignof(Tcb));
-			tlsAddress = tcbAddress + sizeof(Tcb);
-		}
-		__ensure((tlsAddress & (tlsMaxAlignment - 1)) == 0);
-		__ensure(tlsAddress == tcbAddress + sizeof(Tcb));
-	} else {
-		// The TCB should be aligned such that the preceding blocks are aligned too.
-		tcbAddress = alignUp(allocation + tlsInitialSize, alignOverhead);
-		tlsAddress = tcbAddress - tlsInitialSize;
-	}
-	__ensure((tcbAddress & (alignof(Tcb) - 1)) == 0);
-
-	if (verbose) {
-		mlibc::infoLogger() << "rtld: tcb allocated at " << (void *)tcbAddress
-				<< ", size = 0x" << frg::hex_fmt{sizeof(Tcb)} << frg::endlog;
-		mlibc::infoLogger() << "rtld: tls allocated at " << (void *)tlsAddress
-				<< ", size = 0x" << frg::hex_fmt{tlsInitialSize} << frg::endlog;
-	}
-
-	Tcb *tcb_ptr = new ((char *)tcbAddress) Tcb;
-	tcb_ptr->selfPointer = tcb_ptr;
-
-	tcb_ptr->stackCanary = __stack_chk_guard;
-	tcb_ptr->cancelBits = tcbCancelEnableBit;
-	tcb_ptr->didExit = 0;
-	tcb_ptr->isJoinable = 1;
-	memset(&tcb_ptr->returnValue, 0, sizeof(tcb_ptr->returnValue));
-	tcb_ptr->localKeys = frg::construct<frg::array<Tcb::LocalKey, PTHREAD_KEYS_MAX>>(getAllocator());
-	tcb_ptr->dtvSize = runtimeTlsMap->indices.size();
-	tcb_ptr->dtvPointers = frg::construct_n<void *>(getAllocator(), runtimeTlsMap->indices.size());
-	memset(tcb_ptr->dtvPointers, 0, sizeof(void *) * runtimeTlsMap->indices.size());
-	for(size_t i = 0; i < runtimeTlsMap->indices.size(); ++i) {
-		auto object = runtimeTlsMap->indices[i];
-		if(object->tlsModel != TlsModel::initial)
-			continue;
-
-		if constexpr (tlsAboveTp) {
-			tcb_ptr->dtvPointers[i] = reinterpret_cast<char *>(tcb_ptr) + sizeof(Tcb) + object->tlsOffset;
-		} else {
-			tcb_ptr->dtvPointers[i] = reinterpret_cast<char *>(tcb_ptr) + object->tlsOffset;
-		}
-	}
-
-	return tcb_ptr;
+  size_t tlsInitialSize = runtimeTlsMap->initialLimit;
+
+  // To make sure that both the TCB and TLS data are sufficiently aligned,
+  // allocate slightly more than necessary and adjust alignment afterwards.
+  size_t alignOverhead = frg::max(alignof(Tcb), tlsMaxAlignment);
+  size_t allocSize = tlsInitialSize + sizeof(Tcb) + alignOverhead;
+  auto allocation =
+      reinterpret_cast<uintptr_t>(getAllocator().allocate(allocSize));
+  memset(reinterpret_cast<void *>(allocation), 0, allocSize);
+
+  uintptr_t tlsAddress, tcbAddress;
+  if constexpr (tlsAboveTp) {
+    // Here we must satisfy two requirements of the TCB and the TLS data:
+    //   1. One should follow the other immediately in memory. We do this so
+    //   that
+    //      we can simply add or subtract sizeof(Tcb) to obtain the address of
+    //      the other.
+    //   2. Both should be sufficiently aligned.
+    // To do this, we will fix whichever address has stricter alignment
+    // requirements, and derive the other from it.
+    if (tlsMaxAlignment > alignof(Tcb)) {
+      tlsAddress = alignUp(allocation + sizeof(Tcb), tlsMaxAlignment);
+      tcbAddress = tlsAddress - sizeof(Tcb);
+    } else {
+      tcbAddress = alignUp(allocation, alignof(Tcb));
+      tlsAddress = tcbAddress + sizeof(Tcb);
+    }
+    __ensure((tlsAddress & (tlsMaxAlignment - 1)) == 0);
+    __ensure(tlsAddress == tcbAddress + sizeof(Tcb));
+  } else {
+    // The TCB should be aligned such that the preceding blocks are aligned too.
+    tcbAddress = alignUp(allocation + tlsInitialSize, alignOverhead);
+    tlsAddress = tcbAddress - tlsInitialSize;
+  }
+  __ensure((tcbAddress & (alignof(Tcb) - 1)) == 0);
+
+  if (verbose) {
+    mlibc::infoLogger() << "rtld: tcb allocated at " << (void *)tcbAddress
+                        << ", size = 0x" << frg::hex_fmt{sizeof(Tcb)}
+                        << frg::endlog;
+    mlibc::infoLogger() << "rtld: tls allocated at " << (void *)tlsAddress
+                        << ", size = 0x" << frg::hex_fmt{tlsInitialSize}
+                        << frg::endlog;
+  }
+
+  Tcb *tcb_ptr = new ((char *)tcbAddress) Tcb;
+  tcb_ptr->selfPointer = tcb_ptr;
+
+  tcb_ptr->stackCanary = __stack_chk_guard;
+  tcb_ptr->cancelBits = tcbCancelEnableBit;
+  tcb_ptr->didExit = 0;
+  tcb_ptr->isJoinable = 1;
+  memset(&tcb_ptr->returnValue, 0, sizeof(tcb_ptr->returnValue));
+  tcb_ptr->localKeys =
+      frg::construct<frg::array<Tcb::LocalKey, PTHREAD_KEYS_MAX>>(
+          getAllocator());
+  tcb_ptr->dtvSize = runtimeTlsMap->indices.size();
+  tcb_ptr->dtvPointers =
+      frg::construct_n<void *>(getAllocator(), runtimeTlsMap->indices.size());
+  memset(tcb_ptr->dtvPointers, 0,
+         sizeof(void *) * runtimeTlsMap->indices.size());
+  for (size_t i = 0; i < runtimeTlsMap->indices.size(); ++i) {
+    auto object = runtimeTlsMap->indices[i];
+    if (object->tlsModel != TlsModel::initial)
+      continue;
+
+    if constexpr (tlsAboveTp) {
+      tcb_ptr->dtvPointers[i] =
+          reinterpret_cast<char *>(tcb_ptr) + sizeof(Tcb) + object->tlsOffset;
+    } else {
+      tcb_ptr->dtvPointers[i] =
+          reinterpret_cast<char *>(tcb_ptr) + object->tlsOffset;
+    }
+  }
+
+  return tcb_ptr;
 }
 
 void *accessDtv(SharedObject *object) {
-	Tcb *tcb_ptr = mlibc::get_current_tcb();
-
-	// We might need to reallocate the DTV.
-	if(object->tlsIndex >= tcb_ptr->dtvSize) {
-		// TODO: need to protect runtimeTlsMap against concurrent access.
-		auto ndtv = frg::construct_n<void *>(getAllocator(), runtimeTlsMap->indices.size());
-		memset(ndtv, 0, sizeof(void *) * runtimeTlsMap->indices.size());
-		memcpy(ndtv, tcb_ptr->dtvPointers, sizeof(void *) * tcb_ptr->dtvSize);
-		frg::destruct_n(getAllocator(), tcb_ptr->dtvPointers, tcb_ptr->dtvSize);
-		tcb_ptr->dtvSize = runtimeTlsMap->indices.size();
-		tcb_ptr->dtvPointers = ndtv;
-	}
-
-	// We might need to fill in a new DTV entry.
-	if(!tcb_ptr->dtvPointers[object->tlsIndex]) {
-		__ensure(object->tlsModel == TlsModel::dynamic);
-
-		auto buffer = getAllocator().allocate(object->tlsSegmentSize);
-		__ensure(!(reinterpret_cast<uintptr_t>(buffer) & (object->tlsAlignment - 1)));
-		memset(buffer, 0, object->tlsSegmentSize);
-		memcpy(buffer, object->tlsImagePtr, object->tlsImageSize);
-		tcb_ptr->dtvPointers[object->tlsIndex] = buffer;
-
-		if (verbose) {
-			mlibc::infoLogger() << "rtld: accessDtv wrote tls image at " << buffer
-					<< ", size = 0x" << frg::hex_fmt{object->tlsSegmentSize} << frg::endlog;
-		}
-	}
-
-	return (void *)((char *)tcb_ptr->dtvPointers[object->tlsIndex] + TLS_DTV_OFFSET);
+  Tcb *tcb_ptr = mlibc::get_current_tcb();
+
+  // We might need to reallocate the DTV.
+  if (object->tlsIndex >= tcb_ptr->dtvSize) {
+    // TODO: need to protect runtimeTlsMap against concurrent access.
+    auto ndtv =
+        frg::construct_n<void *>(getAllocator(), runtimeTlsMap->indices.size());
+    memset(ndtv, 0, sizeof(void *) * runtimeTlsMap->indices.size());
+    memcpy(ndtv, tcb_ptr->dtvPointers, sizeof(void *) * tcb_ptr->dtvSize);
+    frg::destruct_n(getAllocator(), tcb_ptr->dtvPointers, tcb_ptr->dtvSize);
+    tcb_ptr->dtvSize = runtimeTlsMap->indices.size();
+    tcb_ptr->dtvPointers = ndtv;
+  }
+
+  // We might need to fill in a new DTV entry.
+  if (!tcb_ptr->dtvPointers[object->tlsIndex]) {
+    __ensure(object->tlsModel == TlsModel::dynamic);
+
+    auto buffer = getAllocator().allocate(object->tlsSegmentSize);
+    __ensure(
+        !(reinterpret_cast<uintptr_t>(buffer) & (object->tlsAlignment - 1)));
+    memset(buffer, 0, object->tlsSegmentSize);
+    memcpy(buffer, object->tlsImagePtr, object->tlsImageSize);
+    tcb_ptr->dtvPointers[object->tlsIndex] = buffer;
+
+    if (verbose) {
+      mlibc::infoLogger() << "rtld: accessDtv wrote tls image at " << buffer
+                          << ", size = 0x"
+                          << frg::hex_fmt{object->tlsSegmentSize}
+                          << frg::endlog;
+    }
+  }
+
+  return (void *)((char *)tcb_ptr->dtvPointers[object->tlsIndex] +
+                  TLS_DTV_OFFSET);
 }
 
 void *tryAccessDtv(SharedObject *object) {
-	Tcb *tcb_ptr = mlibc::get_current_tcb();
+  Tcb *tcb_ptr = mlibc::get_current_tcb();
 
-	if (object->tlsIndex >= tcb_ptr->dtvSize)
-		return nullptr;
-	if (!tcb_ptr->dtvPointers[object->tlsIndex])
-		return nullptr;
+  if (object->tlsIndex >= tcb_ptr->dtvSize)
+    return nullptr;
+  if (!tcb_ptr->dtvPointers[object->tlsIndex])
+    return nullptr;
 
-	return (void *)((char *)tcb_ptr->dtvPointers[object->tlsIndex] + TLS_DTV_OFFSET);
+  return (void *)((char *)tcb_ptr->dtvPointers[object->tlsIndex] +
+                  TLS_DTV_OFFSET);
 }
 
 // --------------------------------------------------------
@@ -1402,19 +1443,19 @@ void *tryAccessDtv(SharedObject *object) {
 // --------------------------------------------------------
 
 ObjectSymbol::ObjectSymbol(SharedObject *object, const elf_sym *symbol)
-: _object(object), _symbol(symbol) { }
+    : _object(object), _symbol(symbol) {}
 
 const char *ObjectSymbol::getString() {
-	__ensure(_symbol->st_name != 0);
-	return (const char *)(_object->baseAddress
-			+ _object->stringTableOffset + _symbol->st_name);
+  __ensure(_symbol->st_name != 0);
+  return (const char *)(_object->baseAddress + _object->stringTableOffset +
+                        _symbol->st_name);
 }
 
 uintptr_t ObjectSymbol::virtualAddress() {
-	auto bind = ELF_ST_BIND(_symbol->st_info);
-	__ensure(bind == STB_GLOBAL || bind == STB_WEAK || bind == STB_GNU_UNIQUE);
-	__ensure(_symbol->st_shndx != SHN_UNDEF);
-	return _object->baseAddress + _symbol->st_value;
+  auto bind = ELF_ST_BIND(_symbol->st_info);
+  __ensure(bind == STB_GLOBAL || bind == STB_WEAK || bind == STB_GNU_UNIQUE);
+  __ensure(_symbol->st_shndx != SHN_UNDEF);
+  return _object->baseAddress + _symbol->st_value;
 }
 
 // --------------------------------------------------------
@@ -1422,652 +1463,692 @@ uintptr_t ObjectSymbol::virtualAddress() {
 // --------------------------------------------------------
 
 uint32_t elf64Hash(frg::string_view string) {
-	uint32_t h = 0, g;
+  uint32_t h = 0, g;
 
-	for(size_t i = 0; i < string.size(); ++i) {
-		h = (h << 4) + (uint32_t)string[i];
-		g = h & 0xF0000000;
-		if(g)
-			h ^= g >> 24;
-		h &= 0x0FFFFFFF;
-	}
+  for (size_t i = 0; i < string.size(); ++i) {
+    h = (h << 4) + (uint32_t)string[i];
+    g = h & 0xF0000000;
+    if (g)
+      h ^= g >> 24;
+    h &= 0x0FFFFFFF;
+  }
 
-	return h;
+  return h;
 }
 
 uint32_t gnuHash(frg::string_view string) {
-    uint32_t h = 5381;
-	for(size_t i = 0; i < string.size(); ++i)
-        h = (h << 5) + h + string[i];
-    return h;
+  uint32_t h = 5381;
+  for (size_t i = 0; i < string.size(); ++i)
+    h = (h << 5) + h + string[i];
+  return h;
 }
 
 // TODO: move this to some namespace or class?
-frg::optional<ObjectSymbol> resolveInObject(SharedObject *object, frg::string_view string,
-		frg::optional<SymbolVersion> version) {
-	// Checks if the symbol can be used to satisfy the dependency.
-	auto eligible = [&] (ObjectSymbol cand) {
-		if(cand.symbol()->st_shndx == SHN_UNDEF)
-			return false;
-
-		auto bind = ELF_ST_BIND(cand.symbol()->st_info);
-		if(bind != STB_GLOBAL && bind != STB_WEAK && bind != STB_GNU_UNIQUE)
-			return false;
-
-		return true;
-	};
-
-	// Checks if the symbol's version matches the desired version.
-	auto correctVersion = [&] (SymbolVersion candVersion) {
-		// TODO(qookie): Not sure if local symbols should participate in dynamic symbol resolution
-		if(!version && (candVersion.isDefault() || candVersion.isLocal() || candVersion.isGlobal()))
-			return true;
-		// Caller requested default version, but this isn't it.
-		if(!version)
-			return false;
-		// If the requested version is global (caller has VERNEED but not for this symbol),
-		// use the default one.
-		if(version->isGlobal() && !candVersion.isGlobal() && !candVersion.isLocal() && candVersion.isDefault())
-			return true;
-		return *version == candVersion;
-	};
-
-	if (object->hashStyle == HashStyle::systemV) {
-		auto hash_table = (Elf64_Word *)(object->baseAddress + object->hashTableOffset);
-		Elf64_Word num_buckets = hash_table[0];
-		auto bucket = elf64Hash(string) % num_buckets;
-
-		auto index = hash_table[2 + bucket];
-		while(index != 0) {
-			auto [cand, ver] = object->getSymbolByIndex(index);
-			if(eligible(cand) && frg::string_view{cand.getString()} == string && correctVersion(ver))
-				return cand;
-
-			index = hash_table[2 + num_buckets + index];
-		}
-
-		return frg::optional<ObjectSymbol>{};
-	}else{
-		__ensure(object->hashStyle == HashStyle::gnu);
-
-		struct GnuTable {
-			uint32_t nBuckets;
-			uint32_t symbolOffset;
-			uint32_t bloomSize;
-			uint32_t bloomShift;
-		};
-
-		auto hash_table = reinterpret_cast<const GnuTable *>(object->baseAddress
-				+ object->hashTableOffset);
-		auto buckets = reinterpret_cast<const uint32_t *>(object->baseAddress
-				+ object->hashTableOffset + sizeof(GnuTable)
-				+ hash_table->bloomSize * sizeof(elf_addr));
-		auto chains = reinterpret_cast<const uint32_t *>(object->baseAddress
-				+ object->hashTableOffset + sizeof(GnuTable)
-				+ hash_table->bloomSize * sizeof(elf_addr)
-				+ hash_table->nBuckets * sizeof(uint32_t));
-
-		// TODO: Use the bloom filter.
-
-		// The symbols of a given bucket are contiguous in the table.
-		auto hash = gnuHash(string);
-		auto index = buckets[hash % hash_table->nBuckets];
-
-		if(!index)
-			return frg::optional<ObjectSymbol>{};
-
-		while(true) {
-			// chains[] contains an array of hashes, parallel to the symbol table.
-			auto chash = chains[index - hash_table->symbolOffset];
-			if ((chash & ~1) == (hash & ~1)) {
-				auto [cand, ver] = object->getSymbolByIndex(index);
-				if(eligible(cand) && frg::string_view{cand.getString()} == string && correctVersion(ver))
-					return cand;
-			}
-
-			// If we hit the end of the chain, the symbol is not present.
-			if(chash & 1)
-				return frg::optional<ObjectSymbol>{};
-			index++;
-		}
-	}
+frg::optional<ObjectSymbol>
+resolveInObject(SharedObject *object, frg::string_view string,
+                frg::optional<SymbolVersion> version) {
+  // Checks if the symbol can be used to satisfy the dependency.
+  auto eligible = [&](ObjectSymbol cand) {
+    if (cand.symbol()->st_shndx == SHN_UNDEF)
+      return false;
+
+    auto bind = ELF_ST_BIND(cand.symbol()->st_info);
+    if (bind != STB_GLOBAL && bind != STB_WEAK && bind != STB_GNU_UNIQUE)
+      return false;
+
+    return true;
+  };
+
+  // Checks if the symbol's version matches the desired version.
+  auto correctVersion = [&](SymbolVersion candVersion) {
+    // TODO(qookie): Not sure if local symbols should participate in dynamic
+    // symbol resolution
+    if (!version && (candVersion.isDefault() || candVersion.isLocal() ||
+                     candVersion.isGlobal()))
+      return true;
+    // Caller requested default version, but this isn't it.
+    if (!version)
+      return false;
+    // If the requested version is global (caller has VERNEED but not for this
+    // symbol), use the default one.
+    if (version->isGlobal() && !candVersion.isGlobal() &&
+        !candVersion.isLocal() && candVersion.isDefault())
+      return true;
+    return *version == candVersion;
+  };
+
+  if (object->hashStyle == HashStyle::systemV) {
+    auto hash_table =
+        (Elf64_Word *)(object->baseAddress + object->hashTableOffset);
+    Elf64_Word num_buckets = hash_table[0];
+    auto bucket = elf64Hash(string) % num_buckets;
+
+    auto index = hash_table[2 + bucket];
+    while (index != 0) {
+      auto [cand, ver] = object->getSymbolByIndex(index);
+      if (eligible(cand) && frg::string_view{cand.getString()} == string &&
+          correctVersion(ver))
+        return cand;
+
+      index = hash_table[2 + num_buckets + index];
+    }
+
+    return frg::optional<ObjectSymbol>{};
+  } else {
+    __ensure(object->hashStyle == HashStyle::gnu);
+
+    struct GnuTable {
+      uint32_t nBuckets;
+      uint32_t symbolOffset;
+      uint32_t bloomSize;
+      uint32_t bloomShift;
+    };
+
+    auto hash_table = reinterpret_cast<const GnuTable *>(
+        object->baseAddress + object->hashTableOffset);
+    auto buckets = reinterpret_cast<const uint32_t *>(
+        object->baseAddress + object->hashTableOffset + sizeof(GnuTable) +
+        hash_table->bloomSize * sizeof(elf_addr));
+    auto chains = reinterpret_cast<const uint32_t *>(
+        object->baseAddress + object->hashTableOffset + sizeof(GnuTable) +
+        hash_table->bloomSize * sizeof(elf_addr) +
+        hash_table->nBuckets * sizeof(uint32_t));
+
+    // TODO: Use the bloom filter.
+
+    // The symbols of a given bucket are contiguous in the table.
+    auto hash = gnuHash(string);
+    auto index = buckets[hash % hash_table->nBuckets];
+
+    if (!index)
+      return frg::optional<ObjectSymbol>{};
+
+    while (true) {
+      // chains[] contains an array of hashes, parallel to the symbol table.
+      auto chash = chains[index - hash_table->symbolOffset];
+      if ((chash & ~1) == (hash & ~1)) {
+        auto [cand, ver] = object->getSymbolByIndex(index);
+        if (eligible(cand) && frg::string_view{cand.getString()} == string &&
+            correctVersion(ver))
+          return cand;
+      }
+
+      // If we hit the end of the chain, the symbol is not present.
+      if (chash & 1)
+        return frg::optional<ObjectSymbol>{};
+      index++;
+    }
+  }
 }
 
-frg::optional<ObjectSymbol> Scope::_resolveNext(frg::string_view string,
-		SharedObject *target, frg::optional<SymbolVersion> version) {
-	// Skip objects until we find the target, and only look for symbols after that.
-	size_t i;
-	for (i = 0; i < _objects.size(); i++) {
-		if (_objects[i] == target)
-			break;
-	}
-
-	if (i == _objects.size()) {
-		mlibc::infoLogger() << "rtld: object passed to Scope::resolveAfter was not found" << frg::endlog;
-		return frg::optional<ObjectSymbol>();
-	}
-
-	for (i = i + 1; i < _objects.size(); i++) {
-		if(_objects[i]->isMainObject)
-			continue;
-
-		frg::optional<ObjectSymbol> p = resolveInObject(_objects[i], string, version);
-		if(p)
-			return p;
-	}
-
-	return frg::optional<ObjectSymbol>();
+frg::optional<ObjectSymbol>
+Scope::_resolveNext(frg::string_view string, SharedObject *target,
+                    frg::optional<SymbolVersion> version) {
+  // Skip objects until we find the target, and only look for symbols after
+  // that.
+  size_t i;
+  for (i = 0; i < _objects.size(); i++) {
+    if (_objects[i] == target)
+      break;
+  }
+
+  if (i == _objects.size()) {
+    mlibc::infoLogger()
+        << "rtld: object passed to Scope::resolveAfter was not found"
+        << frg::endlog;
+    return frg::optional<ObjectSymbol>();
+  }
+
+  for (i = i + 1; i < _objects.size(); i++) {
+    if (_objects[i]->isMainObject)
+      continue;
+
+    frg::optional<ObjectSymbol> p =
+        resolveInObject(_objects[i], string, version);
+    if (p)
+      return p;
+  }
+
+  return frg::optional<ObjectSymbol>();
 }
 
-Scope::Scope(bool isGlobal)
-: isGlobal{isGlobal}, _objects(getAllocator()) { }
+Scope::Scope(bool isGlobal) : isGlobal{isGlobal}, _objects(getAllocator()) {}
 
 void Scope::appendObject(SharedObject *object) {
-	// Don't insert duplicates.
-	for (auto obj : _objects) {
-		if (obj == object)
-			return;
-	}
+  // Don't insert duplicates.
+  for (auto obj : _objects) {
+    if (obj == object)
+      return;
+  }
 
-	_objects.push(object);
+  _objects.push(object);
 }
 
-frg::optional<ObjectSymbol> Scope::resolveGlobalOrLocal(Scope &globalScope,
-		Scope *localScope, frg::string_view string, uint64_t skipRts, ResolveFlags flags,
-		frg::optional<SymbolVersion> version) {
-	auto sym = globalScope.resolveSymbol(string, skipRts, flags | skipGlobalAfterRts, version);
-	if(!sym && localScope)
-		sym = localScope->resolveSymbol(string, skipRts, flags | skipGlobalAfterRts, version);
-	return sym;
+frg::optional<ObjectSymbol>
+Scope::resolveGlobalOrLocal(Scope &globalScope, Scope *localScope,
+                            frg::string_view string, uint64_t skipRts,
+                            ResolveFlags flags,
+                            frg::optional<SymbolVersion> version) {
+  auto sym = globalScope.resolveSymbol(string, skipRts,
+                                       flags | skipGlobalAfterRts, version);
+  if (!sym && localScope)
+    sym = localScope->resolveSymbol(string, skipRts, flags | skipGlobalAfterRts,
+                                    version);
+  return sym;
 }
 
-frg::optional<ObjectSymbol> Scope::resolveGlobalOrLocalNext(Scope &globalScope,
-		Scope *localScope, frg::string_view string, SharedObject *origin,
-		frg::optional<SymbolVersion> version) {
-	auto sym = globalScope._resolveNext(string, origin, version);
-	if(!sym && localScope) {
-		sym = localScope->_resolveNext(string, origin, version);
-	}
-	return sym;
+frg::optional<ObjectSymbol>
+Scope::resolveGlobalOrLocalNext(Scope &globalScope, Scope *localScope,
+                                frg::string_view string, SharedObject *origin,
+                                frg::optional<SymbolVersion> version) {
+  auto sym = globalScope._resolveNext(string, origin, version);
+  if (!sym && localScope) {
+    sym = localScope->_resolveNext(string, origin, version);
+  }
+  return sym;
 }
 
 // TODO: let this return uintptr_t
-frg::optional<ObjectSymbol> Scope::resolveSymbol(frg::string_view string,
-		uint64_t skipRts, ResolveFlags flags,
-		frg::optional<SymbolVersion> version) {
-	for (auto object : _objects) {
-		if((flags & resolveCopy) && object->isMainObject)
-			continue;
-		if((flags & skipGlobalAfterRts) && object->globalRts > skipRts) {
-			// globalRts should be monotone increasing for objects in the global scope,
-			// so as an optimization we can break early here.
-			// TODO: If we implement DT_SYMBOLIC, this assumption fails.
-			if(isGlobal)
-				break;
-			else
-				continue;
-		}
-
-		frg::optional<ObjectSymbol> p = resolveInObject(object, string, version);
-		if(p)
-			return p;
-	}
-
-	return frg::optional<ObjectSymbol>();
+frg::optional<ObjectSymbol>
+Scope::resolveSymbol(frg::string_view string, uint64_t skipRts,
+                     ResolveFlags flags, frg::optional<SymbolVersion> version) {
+  for (auto object : _objects) {
+    if ((flags & resolveCopy) && object->isMainObject)
+      continue;
+    if ((flags & skipGlobalAfterRts) && object->globalRts > skipRts) {
+      // globalRts should be monotone increasing for objects in the global
+      // scope, so as an optimization we can break early here.
+      // TODO: If we implement DT_SYMBOLIC, this assumption fails.
+      if (isGlobal)
+        break;
+      else
+        continue;
+    }
+
+    frg::optional<ObjectSymbol> p = resolveInObject(object, string, version);
+    if (p)
+      return p;
+  }
+
+  return frg::optional<ObjectSymbol>();
 }
 
 // --------------------------------------------------------
 // Loader
 // --------------------------------------------------------
 
-Loader::Loader(Scope *scope, SharedObject *mainExecutable, bool is_initial_link, uint64_t rts)
-: _mainExecutable{mainExecutable}, _loadScope{scope}, _isInitialLink{is_initial_link},
-		_linkRts{rts}, _linkBfs{getAllocator()}, _initQueue{getAllocator()} { }
+Loader::Loader(Scope *scope, SharedObject *mainExecutable, bool is_initial_link,
+               uint64_t rts)
+    : _mainExecutable{mainExecutable}, _loadScope{scope},
+      _isInitialLink{is_initial_link}, _linkRts{rts}, _linkBfs{getAllocator()},
+      _initQueue{getAllocator()} {}
 
 void Loader::_buildLinkBfs(SharedObject *root) {
-	__ensure(_linkBfs.size() == 0);
-
-	struct Token {};
-	using Set = frg::hash_map<SharedObject *, Token,
-			frg::hash<SharedObject *>, MemoryAllocator>;
-	Set set{frg::hash<SharedObject *>{}, getAllocator()};
-	_linkBfs.push(root);
-
-	// Loop over indices (not iterators) here: We are adding elements in the loop!
-	for(size_t i = 0; i < _linkBfs.size(); i++) {
-		auto current = _linkBfs[i];
-
-		// At this point the object is loaded and we can fill in its debug struct,
-		// the linked list fields will be filled later.
-		current->linkMap.base = current->baseAddress;
-		current->linkMap.name = current->path.data();
-		current->linkMap.dynv = current->dynamic;
-
-		__ensure((current->tlsAlignment & (current->tlsAlignment - 1)) == 0);
-
-		if (_isInitialLink && current->tlsAlignment > tlsMaxAlignment) {
-			tlsMaxAlignment = current->tlsAlignment;
-		}
-
-		for (auto dep : current->dependencies) {
-			if (!set.get(dep)) {
-				set.insert(dep, Token{});
-				_linkBfs.push(dep);
-			}
-		}
-	}
+  __ensure(_linkBfs.size() == 0);
+
+  struct Token {};
+  using Set = frg::hash_map<SharedObject *, Token, frg::hash<SharedObject *>,
+                            MemoryAllocator>;
+  Set set{frg::hash<SharedObject *>{}, getAllocator()};
+  _linkBfs.push(root);
+
+  // Loop over indices (not iterators) here: We are adding elements in the loop!
+  for (size_t i = 0; i < _linkBfs.size(); i++) {
+    auto current = _linkBfs[i];
+
+    // At this point the object is loaded and we can fill in its debug struct,
+    // the linked list fields will be filled later.
+    current->linkMap.base = current->baseAddress;
+    current->linkMap.name = current->path.data();
+    current->linkMap.dynv = current->dynamic;
+
+    __ensure((current->tlsAlignment & (current->tlsAlignment - 1)) == 0);
+
+    if (_isInitialLink && current->tlsAlignment > tlsMaxAlignment) {
+      tlsMaxAlignment = current->tlsAlignment;
+    }
+
+    for (auto dep : current->dependencies) {
+      if (!set.get(dep)) {
+        set.insert(dep, Token{});
+        _linkBfs.push(dep);
+      }
+    }
+  }
 }
 
 void Loader::linkObjects(SharedObject *root) {
-	_buildLinkBfs(root);
-	_buildTlsMaps();
+  _buildLinkBfs(root);
+  _buildTlsMaps();
 
-	// Promote objects to the desired scope.
-	for(auto object : _linkBfs) {
-		if (object->globalRts == 0 && _loadScope->isGlobal)
-			object->globalRts = _linkRts;
+  // Promote objects to the desired scope.
+  for (auto object : _linkBfs) {
+    if (object->globalRts == 0 && _loadScope->isGlobal)
+      object->globalRts = _linkRts;
 
-		_loadScope->appendObject(object);
-	}
+    _loadScope->appendObject(object);
+  }
 
-	// Process regular relocations.
-	for(auto object : _linkBfs) {
-		// Some objects have already been linked before.
-		if(object->objectRts < _linkRts)
-			continue;
+  // Process regular relocations.
+  for (auto object : _linkBfs) {
+    // Some objects have already been linked before.
+    if (object->objectRts < _linkRts)
+      continue;
 
-		if(object->dynamic == nullptr)
-			continue;
+    if (object->dynamic == nullptr)
+      continue;
 
-		if(verbose)
-			mlibc::infoLogger() << "rtld: Linking " << object->name << frg::endlog;
+    if (verbose)
+      mlibc::infoLogger() << "rtld: Linking " << object->name << frg::endlog;
 
-		__ensure(!object->wasLinked);
+    __ensure(!object->wasLinked);
 
-		// TODO: Support this.
-		if(object->symbolicResolution)
-			mlibc::infoLogger() << "\e[31mrtld: DT_SYMBOLIC is not implemented correctly!\e[39m"
-					<< frg::endlog;
+    // TODO: Support this.
+    if (object->symbolicResolution)
+      mlibc::infoLogger()
+          << "\e[31mrtld: DT_SYMBOLIC is not implemented correctly!\e[39m"
+          << frg::endlog;
 
-		_processStaticRelocations(object);
-		_processLazyRelocations(object);
-	}
+    _processStaticRelocations(object);
+    _processLazyRelocations(object);
+  }
 
-	// Process copy relocations.
-	for(auto object : _linkBfs) {
-		if(!object->isMainObject)
-			continue;
+  // Process copy relocations.
+  for (auto object : _linkBfs) {
+    if (!object->isMainObject)
+      continue;
 
-		// Some objects have already been linked before.
-		if(object->objectRts < _linkRts)
-			continue;
+    // Some objects have already been linked before.
+    if (object->objectRts < _linkRts)
+      continue;
 
-		if(object->dynamic == nullptr)
-			continue;
+    if (object->dynamic == nullptr)
+      continue;
 
-		processLateRelocations(object);
-	}
+    processLateRelocations(object);
+  }
 
-	for(auto object : _linkBfs) {
-		object->wasLinked = true;
+  for (auto object : _linkBfs) {
+    object->wasLinked = true;
 
-		if(object->inLinkMap)
-			continue;
+    if (object->inLinkMap)
+      continue;
 
-		auto linkMap = reinterpret_cast<LinkMap*>(globalDebugInterface.head);
+    auto linkMap = reinterpret_cast<LinkMap *>(globalDebugInterface.head);
 
-		object->linkMap.prev = linkMap;
-		object->linkMap.next = linkMap->next;
-		if(linkMap->next)
-			linkMap->next->prev = &(object->linkMap);
-		linkMap->next = &(object->linkMap);
-		object->inLinkMap = true;
-	}
+    object->linkMap.prev = linkMap;
+    object->linkMap.next = linkMap->next;
+    if (linkMap->next)
+      linkMap->next->prev = &(object->linkMap);
+    linkMap->next = &(object->linkMap);
+    object->inLinkMap = true;
+  }
 }
 
 void Loader::_buildTlsMaps() {
-	if(_isInitialLink) {
-		__ensure(runtimeTlsMap->initialPtr == 0);
-		__ensure(runtimeTlsMap->initialLimit == 0);
-
-		__ensure(!_linkBfs.empty());
-		__ensure(_linkBfs.front()->isMainObject);
-
-		for(auto object : _linkBfs) {
-			__ensure(object->tlsModel == TlsModel::null);
-
-			if(object->tlsSegmentSize == 0)
-				continue;
-
-			// Allocate an index for the object.
-			object->tlsIndex = runtimeTlsMap->indices.size();
-			runtimeTlsMap->indices.push_back(object);
-
-			object->tlsModel = TlsModel::initial;
-
-			if constexpr (tlsAboveTp) {
-				size_t misalign = runtimeTlsMap->initialPtr & (object->tlsAlignment - 1);
-				if(misalign)
-					runtimeTlsMap->initialPtr += object->tlsAlignment - misalign;
-
-				object->tlsOffset = runtimeTlsMap->initialPtr;
-				runtimeTlsMap->initialPtr += object->tlsSegmentSize;
-			} else {
-				runtimeTlsMap->initialPtr += object->tlsSegmentSize;
-
-				size_t misalign = runtimeTlsMap->initialPtr & (object->tlsAlignment - 1);
-				if(misalign)
-					runtimeTlsMap->initialPtr += object->tlsAlignment - misalign;
-
-				object->tlsOffset = -runtimeTlsMap->initialPtr;
-			}
-
-			if(verbose)
-				mlibc::infoLogger() << "rtld: TLS of " << object->name
-						<< " mapped to 0x" << frg::hex_fmt{object->tlsOffset}
-						<< ", size: " << object->tlsSegmentSize
-						<< ", alignment: " << object->tlsAlignment << frg::endlog;
-		}
-
-		// Reserve some additional space for future libraries.
-		runtimeTlsMap->initialLimit = runtimeTlsMap->initialPtr + 64;
-	}else{
-		for(auto object : _linkBfs) {
-			if(object->tlsModel != TlsModel::null)
-				continue;
-			if(object->tlsSegmentSize == 0)
-				continue;
-
-			// Allocate an index for the object.
-			object->tlsIndex = runtimeTlsMap->indices.size();
-			runtimeTlsMap->indices.push_back(object);
-
-			// There are some libraries (e.g. Mesa) that require static TLS even though
-			// they expect to be dynamically loaded.
-			if(object->haveStaticTls) {
-				object->tlsModel = TlsModel::initial;
-
-				if constexpr (tlsAboveTp) {
-					size_t misalign = runtimeTlsMap->initialPtr & (object->tlsAlignment - 1);
-					if(misalign)
-						runtimeTlsMap->initialPtr += object->tlsAlignment - misalign;
-
-					object->tlsOffset = runtimeTlsMap->initialPtr;
-					runtimeTlsMap->initialPtr += object->tlsSegmentSize;
-				} else {
-					runtimeTlsMap->initialPtr += object->tlsSegmentSize;
-
-					size_t misalign = runtimeTlsMap->initialPtr & (object->tlsAlignment - 1);
-					if(misalign)
-						runtimeTlsMap->initialPtr += object->tlsAlignment - misalign;
-
-					object->tlsOffset = -runtimeTlsMap->initialPtr;
-				}
-
-				if(runtimeTlsMap->initialPtr > runtimeTlsMap->initialLimit)
-						mlibc::panicLogger() << "rtld: Static TLS space exhausted while while"
-								" allocating TLS for " << object->name << frg::endlog;
-
-				if(verbose)
-					mlibc::infoLogger() << "rtld: TLS of " << object->name
-							<< " mapped to 0x" << frg::hex_fmt{object->tlsOffset}
-							<< ", size: " << object->tlsSegmentSize
-							<< ", alignment: " << object->tlsAlignment << frg::endlog;
-			}else{
-				object->tlsModel = TlsModel::dynamic;
-			}
-		}
-	}
+  if (_isInitialLink) {
+    __ensure(runtimeTlsMap->initialPtr == 0);
+    __ensure(runtimeTlsMap->initialLimit == 0);
+
+    __ensure(!_linkBfs.empty());
+    __ensure(_linkBfs.front()->isMainObject);
+
+    for (auto object : _linkBfs) {
+      __ensure(object->tlsModel == TlsModel::null);
+
+      if (object->tlsSegmentSize == 0)
+        continue;
+
+      // Allocate an index for the object.
+      object->tlsIndex = runtimeTlsMap->indices.size();
+      runtimeTlsMap->indices.push_back(object);
+
+      object->tlsModel = TlsModel::initial;
+
+      if constexpr (tlsAboveTp) {
+        size_t misalign =
+            runtimeTlsMap->initialPtr & (object->tlsAlignment - 1);
+        if (misalign)
+          runtimeTlsMap->initialPtr += object->tlsAlignment - misalign;
+
+        object->tlsOffset = runtimeTlsMap->initialPtr;
+        runtimeTlsMap->initialPtr += object->tlsSegmentSize;
+      } else {
+        runtimeTlsMap->initialPtr += object->tlsSegmentSize;
+
+        size_t misalign =
+            runtimeTlsMap->initialPtr & (object->tlsAlignment - 1);
+        if (misalign)
+          runtimeTlsMap->initialPtr += object->tlsAlignment - misalign;
+
+        object->tlsOffset = -runtimeTlsMap->initialPtr;
+      }
+
+      if (verbose)
+        mlibc::infoLogger()
+            << "rtld: TLS of " << object->name << " mapped to 0x"
+            << frg::hex_fmt{object->tlsOffset}
+            << ", size: " << object->tlsSegmentSize
+            << ", alignment: " << object->tlsAlignment << frg::endlog;
+    }
+
+    // Reserve some additional space for future libraries.
+    runtimeTlsMap->initialLimit = runtimeTlsMap->initialPtr + 64;
+  } else {
+    for (auto object : _linkBfs) {
+      if (object->tlsModel != TlsModel::null)
+        continue;
+      if (object->tlsSegmentSize == 0)
+        continue;
+
+      // Allocate an index for the object.
+      object->tlsIndex = runtimeTlsMap->indices.size();
+      runtimeTlsMap->indices.push_back(object);
+
+      // There are some libraries (e.g. Mesa) that require static TLS even
+      // though they expect to be dynamically loaded.
+      if (object->haveStaticTls) {
+        object->tlsModel = TlsModel::initial;
+
+        if constexpr (tlsAboveTp) {
+          size_t misalign =
+              runtimeTlsMap->initialPtr & (object->tlsAlignment - 1);
+          if (misalign)
+            runtimeTlsMap->initialPtr += object->tlsAlignment - misalign;
+
+          object->tlsOffset = runtimeTlsMap->initialPtr;
+          runtimeTlsMap->initialPtr += object->tlsSegmentSize;
+        } else {
+          runtimeTlsMap->initialPtr += object->tlsSegmentSize;
+
+          size_t misalign =
+              runtimeTlsMap->initialPtr & (object->tlsAlignment - 1);
+          if (misalign)
+            runtimeTlsMap->initialPtr += object->tlsAlignment - misalign;
+
+          object->tlsOffset = -runtimeTlsMap->initialPtr;
+        }
+
+        if (runtimeTlsMap->initialPtr > runtimeTlsMap->initialLimit)
+          mlibc::panicLogger() << "rtld: Static TLS space exhausted while while"
+                                  " allocating TLS for "
+                               << object->name << frg::endlog;
+
+        if (verbose)
+          mlibc::infoLogger()
+              << "rtld: TLS of " << object->name << " mapped to 0x"
+              << frg::hex_fmt{object->tlsOffset}
+              << ", size: " << object->tlsSegmentSize
+              << ", alignment: " << object->tlsAlignment << frg::endlog;
+      } else {
+        object->tlsModel = TlsModel::dynamic;
+      }
+    }
+  }
 }
 
 void Loader::initObjects(ObjectRepository *repository) {
-	initTlsObjects(mlibc::get_current_tcb(), _linkBfs, true);
-
-	if (_mainExecutable && _mainExecutable->preInitArray) {
-		if (verbose)
-			mlibc::infoLogger() << "rtld: Running DT_PREINIT_ARRAY functions" << frg::endlog;
-
-		__ensure(_mainExecutable->isMainObject);
-		__ensure(!_mainExecutable->wasInitialized);
-		__ensure((_mainExecutable->preInitArraySize % sizeof(InitFuncPtr)) == 0);
-		for(size_t i = 0; i < _mainExecutable->preInitArraySize / sizeof(InitFuncPtr); i++)
-			_mainExecutable->preInitArray[i]();
-	}
-
-	// Convert the breadth-first representation to a depth-first post-order representation,
-	// so that every object is initialized *after* its dependencies.
-	for(auto object : _linkBfs) {
-		if(!object->scheduledForInit)
-			_scheduleInit(object);
-	}
-
-	for(auto object : _initQueue) {
-		if(!object->wasInitialized) {
-			doInitialize(object);
-			repository->addObjectToDestructQueue(object);
-		}
-	}
+  initTlsObjects(mlibc::get_current_tcb(), _linkBfs, true);
+
+  if (_mainExecutable && _mainExecutable->preInitArray) {
+    if (verbose)
+      mlibc::infoLogger() << "rtld: Running DT_PREINIT_ARRAY functions"
+                          << frg::endlog;
+
+    __ensure(_mainExecutable->isMainObject);
+    __ensure(!_mainExecutable->wasInitialized);
+    __ensure((_mainExecutable->preInitArraySize % sizeof(InitFuncPtr)) == 0);
+    for (size_t i = 0;
+         i < _mainExecutable->preInitArraySize / sizeof(InitFuncPtr); i++)
+      _mainExecutable->preInitArray[i]();
+  }
+
+  // Convert the breadth-first representation to a depth-first post-order
+  // representation, so that every object is initialized *after* its
+  // dependencies.
+  for (auto object : _linkBfs) {
+    if (!object->scheduledForInit)
+      _scheduleInit(object);
+  }
+
+  for (auto object : _initQueue) {
+    if (!object->wasInitialized) {
+      doInitialize(object);
+      repository->addObjectToDestructQueue(object);
+    }
+  }
 }
 
 // TODO: Use an explicit vector to reduce stack usage to O(1)?
 void Loader::_scheduleInit(SharedObject *object) {
-	// Here we detect cyclic dependencies.
-	__ensure(!object->onInitStack);
-	object->onInitStack = true;
+  // Here we detect cyclic dependencies.
+  __ensure(!object->onInitStack);
+  object->onInitStack = true;
 
-	__ensure(!object->scheduledForInit);
-	object->scheduledForInit = true;
+  __ensure(!object->scheduledForInit);
+  object->scheduledForInit = true;
 
-	for(size_t i = 0; i < object->dependencies.size(); i++) {
-		if(!object->dependencies[i]->scheduledForInit)
-			_scheduleInit(object->dependencies[i]);
-	}
+  for (size_t i = 0; i < object->dependencies.size(); i++) {
+    if (!object->dependencies[i]->scheduledForInit)
+      _scheduleInit(object->dependencies[i]);
+  }
 
-	_initQueue.push(object);
-	object->onInitStack = false;
+  _initQueue.push(object);
+  object->onInitStack = false;
 }
 
 void Loader::_processRelocations(Relocation &rel) {
-	// copy and irelative relocations have to be performed after all other relocations
-	if(rel.type() == R_COPY || rel.type() == R_IRELATIVE)
-		return;
-
-	// resolve the symbol if there is a symbol
-	frg::optional<ObjectSymbol> p;
-	if(rel.symbol_index()) {
-		auto [sym, ver] = rel.object()->getSymbolByIndex(rel.symbol_index());
-
-		p = Scope::resolveGlobalOrLocal(*globalScope, rel.object()->localScope,
-				sym.getString(), rel.object()->objectRts, 0, ver);
-		if(!p) {
-			if(ELF_ST_BIND(sym.symbol()->st_info) != STB_WEAK)
-				mlibc::panicLogger() << "Unresolved load-time symbol "
-						<< sym.getString() << " in object " << rel.object()->name << frg::endlog;
-
-			if(verbose)
-				mlibc::infoLogger() << "rtld: Unresolved weak load-time symbol "
-						<< sym.getString() << " in object " << rel.object()->name << frg::endlog;
-		}
-	}
-
-	switch(rel.type()) {
-	case R_NONE:
-		break;
-
-	case R_JUMP_SLOT: {
-		__ensure(!rel.addend_norel());
-		uintptr_t symbol_addr = p ? p->virtualAddress() : 0;
-		rel.relocate(symbol_addr);
-	} break;
+  // copy and irelative relocations have to be performed after all other
+  // relocations
+  if (rel.type() == R_COPY || rel.type() == R_IRELATIVE)
+    return;
+
+  // resolve the symbol if there is a symbol
+  frg::optional<ObjectSymbol> p;
+  if (rel.symbol_index()) {
+    auto [sym, ver] = rel.object()->getSymbolByIndex(rel.symbol_index());
+
+    p = Scope::resolveGlobalOrLocal(*globalScope, rel.object()->localScope,
+                                    sym.getString(), rel.object()->objectRts, 0,
+                                    ver);
+    if (!p) {
+      if (ELF_ST_BIND(sym.symbol()->st_info) != STB_WEAK)
+        mlibc::panicLogger()
+            << "Unresolved load-time symbol " << sym.getString()
+            << " in object " << rel.object()->name << frg::endlog;
+
+      if (verbose)
+        mlibc::infoLogger()
+            << "rtld: Unresolved weak load-time symbol " << sym.getString()
+            << " in object " << rel.object()->name << frg::endlog;
+    }
+  }
+
+  switch (rel.type()) {
+  case R_NONE:
+    break;
+
+  case R_JUMP_SLOT: {
+    __ensure(!rel.addend_norel());
+    uintptr_t symbol_addr = p ? p->virtualAddress() : 0;
+    rel.relocate(symbol_addr);
+  } break;
 
 #if !defined(__riscv)
-	// on some architectures, R_GLOB_DAT can be defined to other relocations
-	case R_GLOB_DAT: {
-		__ensure(rel.symbol_index());
-		uintptr_t symbol_addr = p ? p->virtualAddress() : 0;
-		rel.relocate(symbol_addr + rel.addend_norel());
-	} break;
+  // on some architectures, R_GLOB_DAT can be defined to other relocations
+  case R_GLOB_DAT: {
+    __ensure(rel.symbol_index());
+    uintptr_t symbol_addr = p ? p->virtualAddress() : 0;
+    rel.relocate(symbol_addr + rel.addend_norel());
+  } break;
 #endif
 
-	case R_ABSOLUTE: {
-		__ensure(rel.symbol_index());
-		uintptr_t symbol_addr = p ? p->virtualAddress() : 0;
-		rel.relocate(symbol_addr + rel.addend_rel());
-	} break;
-
-	case R_RELATIVE: {
-		__ensure(!rel.symbol_index());
-		rel.relocate(rel.object()->baseAddress + rel.addend_rel());
-	} break;
-
-	// DTPMOD and DTPREL are dynamic TLS relocations (for __tls_get_addr()).
-	// TPOFF is a relocation to the initial TLS model.
-	case R_TLS_DTPMOD: {
-		// sets the first `sizeof(uintptr_t)` bytes of `struct __abi_tls_entry`
-		// this means that we can just use the `SharedObject *` to resolve whatever we need
-		__ensure(!rel.addend_rel());
-		if(rel.symbol_index()) {
-			__ensure(p);
-			rel.relocate(elf_addr(p->object()));
-		}else{
-			if(stillSlightlyVerbose)
-				mlibc::infoLogger() << "rtld: Warning: TLS_DTPMOD64 with no symbol in object "
-					<< rel.object()->name << frg::endlog;
-			rel.relocate(elf_addr(rel.object()));
-		}
-	} break;
-	case R_TLS_DTPREL: {
-		__ensure(rel.symbol_index());
-		__ensure(p);
-		rel.relocate(p->symbol()->st_value + rel.addend_rel() - TLS_DTV_OFFSET);
-	} break;
-	case R_TLS_TPREL: {
-		uintptr_t off = rel.addend_rel();
-		ssize_t tls_offset = 0;
-
-		if(rel.symbol_index()) {
-			__ensure(p);
-			if(p->object()->tlsModel != TlsModel::initial)
-				mlibc::panicLogger() << "rtld: In object " << rel.object()->name
-						<< ": Static TLS relocation to symbol " << p->getString()
-						<< " in dynamically loaded object "
-						<< p->object()->name << frg::endlog;
-			off += p->symbol()->st_value;
-			tls_offset = p->object()->tlsOffset;
-		}else{
-			if(stillSlightlyVerbose)
-				mlibc::infoLogger() << "rtld: Warning: TPOFF64 with no symbol"
-						" in object " << rel.object()->name << frg::endlog;
-			if(rel.object()->tlsModel != TlsModel::initial)
-				mlibc::panicLogger() << "rtld: In object " << rel.object()->name
-						<< ": Static TLS relocation to dynamically loaded object "
-						<< rel.object()->name << frg::endlog;
-			tls_offset = rel.object()->tlsOffset;
-		}
-
-		off += tls_offset + tlsOffsetFromTp;
-		rel.relocate(off);
-	} break;
-	default:
-		mlibc::panicLogger() << "Unexpected relocation type "
-				<< (void *) rel.type() << frg::endlog;
-	}
+  case R_ABSOLUTE: {
+    __ensure(rel.symbol_index());
+    uintptr_t symbol_addr = p ? p->virtualAddress() : 0;
+    rel.relocate(symbol_addr + rel.addend_rel());
+  } break;
+
+  case R_RELATIVE: {
+    __ensure(!rel.symbol_index());
+    rel.relocate(rel.object()->baseAddress + rel.addend_rel());
+  } break;
+
+  // DTPMOD and DTPREL are dynamic TLS relocations (for __tls_get_addr()).
+  // TPOFF is a relocation to the initial TLS model.
+  case R_TLS_DTPMOD: {
+    // sets the first `sizeof(uintptr_t)` bytes of `struct __abi_tls_entry`
+    // this means that we can just use the `SharedObject *` to resolve whatever
+    // we need
+    __ensure(!rel.addend_rel());
+    if (rel.symbol_index()) {
+      __ensure(p);
+      rel.relocate(elf_addr(p->object()));
+    } else {
+      if (stillSlightlyVerbose)
+        mlibc::infoLogger()
+            << "rtld: Warning: TLS_DTPMOD64 with no symbol in object "
+            << rel.object()->name << frg::endlog;
+      rel.relocate(elf_addr(rel.object()));
+    }
+  } break;
+  case R_TLS_DTPREL: {
+    __ensure(rel.symbol_index());
+    __ensure(p);
+    rel.relocate(p->symbol()->st_value + rel.addend_rel() - TLS_DTV_OFFSET);
+  } break;
+  case R_TLS_TPREL: {
+    uintptr_t off = rel.addend_rel();
+    ssize_t tls_offset = 0;
+
+    if (rel.symbol_index()) {
+      __ensure(p);
+      if (p->object()->tlsModel != TlsModel::initial)
+        mlibc::panicLogger()
+            << "rtld: In object " << rel.object()->name
+            << ": Static TLS relocation to symbol " << p->getString()
+            << " in dynamically loaded object " << p->object()->name
+            << frg::endlog;
+      off += p->symbol()->st_value;
+      tls_offset = p->object()->tlsOffset;
+    } else {
+      if (stillSlightlyVerbose)
+        mlibc::infoLogger() << "rtld: Warning: TPOFF64 with no symbol"
+                               " in object "
+                            << rel.object()->name << frg::endlog;
+      if (rel.object()->tlsModel != TlsModel::initial)
+        mlibc::panicLogger()
+            << "rtld: In object " << rel.object()->name
+            << ": Static TLS relocation to dynamically loaded object "
+            << rel.object()->name << frg::endlog;
+      tls_offset = rel.object()->tlsOffset;
+    }
+
+    off += tls_offset + tlsOffsetFromTp;
+    rel.relocate(off);
+  } break;
+  default:
+    mlibc::panicLogger() << "Unexpected relocation type " << (void *)rel.type()
+                         << frg::endlog;
+  }
 }
 
 void Loader::_processStaticRelocations(SharedObject *object) {
-	frg::optional<uintptr_t> rela_offset;
-	frg::optional<size_t> rela_length;
-
-	frg::optional<uintptr_t> rel_offset;
-	frg::optional<size_t> rel_length;
-
-	frg::optional<uintptr_t> relr_offset;
-	frg::optional<size_t> relr_length;
-
-	for(size_t i = 0; object->dynamic[i].d_tag != DT_NULL; i++) {
-		elf_dyn *dynamic = &object->dynamic[i];
-
-		switch(dynamic->d_tag) {
-		case DT_RELA:
-			rela_offset = dynamic->d_un.d_ptr;
-			break;
-		case DT_RELASZ:
-			rela_length = dynamic->d_un.d_val;
-			break;
-		case DT_RELAENT:
-			__ensure(dynamic->d_un.d_val == sizeof(elf_rela));
-			break;
-		case DT_REL:
-			rel_offset = dynamic->d_un.d_ptr;
-			break;
-		case DT_RELSZ:
-			rel_length = dynamic->d_un.d_val;
-			break;
-		case DT_RELENT:
-			__ensure(dynamic->d_un.d_val == sizeof(elf_rel));
-			break;
-		case DT_RELR:
-			relr_offset = dynamic->d_un.d_ptr;
-			break;
-		case DT_RELRSZ:
-			relr_length = dynamic->d_un.d_val;
-			break;
-		case DT_RELRENT:
-			__ensure(dynamic->d_un.d_val == sizeof(elf_relr));
-			break;
-		}
-	}
-
-	if(rela_offset && rela_length) {
-		__ensure(!rel_offset && !rel_length);
-
-		for(size_t offset = 0; offset < *rela_length; offset += sizeof(elf_rela)) {
-			auto reloc = (elf_rela *)(object->baseAddress + *rela_offset + offset);
-			auto r = Relocation(object, reloc);
-
-			_processRelocations(r);
-		}
-	}else if(rel_offset && rel_length) {
-		__ensure(!rela_offset && !rela_length);
-
-		for(size_t offset = 0; offset < *rel_length; offset += sizeof(elf_rel)) {
-			auto reloc = (elf_rel *)(object->baseAddress + *rel_offset + offset);
-			auto r = Relocation(object, reloc);
-
-			_processRelocations(r);
-		}
-	}
-
-	if(relr_offset && relr_length) {
-		elf_addr *addr = nullptr;
-
-		for(size_t offset = 0; offset < *relr_length; offset += sizeof(elf_relr)) {
-			auto entry = *(elf_relr *)(object->baseAddress + *relr_offset + offset);
-
-			// Even entry indicates the beginning address.
-			if(!(entry & 1)) {
-				addr = (elf_addr *)(object->baseAddress + entry);
-				__ensure(addr);
-				*addr++ += object->baseAddress;
-			}else {
-				// Odd entry indicates entry is a bitmap of the subsequent locations to be relocated.
-
-				// The first bit of an entry is always a marker about whether the entry is an address or a bitmap,
-				// discard it.
-				entry >>= 1;
-
-				for(int i = 0; entry; ++i) {
-					if(entry & 1) {
-						addr[i] += object->baseAddress;
-					}
-					entry >>= 1;
-				}
-
-				// Each entry describes at max 63 (on 64bit) or 31 (on 32bit) subsequent locations.
-				addr += CHAR_BIT * sizeof(elf_relr) - 1;
-			}
-		}
-	}
+  frg::optional<uintptr_t> rela_offset;
+  frg::optional<size_t> rela_length;
+
+  frg::optional<uintptr_t> rel_offset;
+  frg::optional<size_t> rel_length;
+
+  frg::optional<uintptr_t> relr_offset;
+  frg::optional<size_t> relr_length;
+
+  for (size_t i = 0; object->dynamic[i].d_tag != DT_NULL; i++) {
+    elf_dyn *dynamic = &object->dynamic[i];
+
+    switch (dynamic->d_tag) {
+    case DT_RELA:
+      rela_offset = dynamic->d_un.d_ptr;
+      break;
+    case DT_RELASZ:
+      rela_length = dynamic->d_un.d_val;
+      break;
+    case DT_RELAENT:
+      __ensure(dynamic->d_un.d_val == sizeof(elf_rela));
+      break;
+    case DT_REL:
+      rel_offset = dynamic->d_un.d_ptr;
+      break;
+    case DT_RELSZ:
+      rel_length = dynamic->d_un.d_val;
+      break;
+    case DT_RELENT:
+      __ensure(dynamic->d_un.d_val == sizeof(elf_rel));
+      break;
+    case DT_RELR:
+      relr_offset = dynamic->d_un.d_ptr;
+      break;
+    case DT_RELRSZ:
+      relr_length = dynamic->d_un.d_val;
+      break;
+    case DT_RELRENT:
+      __ensure(dynamic->d_un.d_val == sizeof(elf_relr));
+      break;
+    }
+  }
+
+  if (rela_offset && rela_length) {
+    __ensure(!rel_offset && !rel_length);
+
+    for (size_t offset = 0; offset < *rela_length; offset += sizeof(elf_rela)) {
+      auto reloc = (elf_rela *)(object->baseAddress + *rela_offset + offset);
+      auto r = Relocation(object, reloc);
+
+      _processRelocations(r);
+    }
+  } else if (rel_offset && rel_length) {
+    __ensure(!rela_offset && !rela_length);
+
+    for (size_t offset = 0; offset < *rel_length; offset += sizeof(elf_rel)) {
+      auto reloc = (elf_rel *)(object->baseAddress + *rel_offset + offset);
+      auto r = Relocation(object, reloc);
+
+      _processRelocations(r);
+    }
+  }
+
+  if (relr_offset && relr_length) {
+    elf_addr *addr = nullptr;
+
+    for (size_t offset = 0; offset < *relr_length; offset += sizeof(elf_relr)) {
+      auto entry = *(elf_relr *)(object->baseAddress + *relr_offset + offset);
+
+      // Even entry indicates the beginning address.
+      if (!(entry & 1)) {
+        addr = (elf_addr *)(object->baseAddress + entry);
+        __ensure(addr);
+        *addr++ += object->baseAddress;
+      } else {
+        // Odd entry indicates entry is a bitmap of the subsequent locations to
+        // be relocated.
+
+        // The first bit of an entry is always a marker about whether the entry
+        // is an address or a bitmap, discard it.
+        entry >>= 1;
+
+        for (int i = 0; entry; ++i) {
+          if (entry & 1) {
+            addr[i] += object->baseAddress;
+          }
+          entry >>= 1;
+        }
+
+        // Each entry describes at max 63 (on 64bit) or 31 (on 32bit) subsequent
+        // locations.
+        addr += CHAR_BIT * sizeof(elf_relr) - 1;
+      }
+    }
+  }
 }
 
 // TODO: TLSDESC relocations aren't aarch64/x86_64 specific
@@ -2077,124 +2158,138 @@ extern "C" void *__mlibcTlsdescDynamic(void *);
 #endif
 
 void Loader::_processLazyRelocations(SharedObject *object) {
-	if(object->globalOffsetTable == nullptr) {
-		__ensure(object->lazyRelocTableOffset == 0);
-		return;
-	}
-	object->globalOffsetTable[1] = object;
-	object->globalOffsetTable[2] = (void *)&pltRelocateStub;
-
-	if(!object->lazyTableSize)
-		return;
-
-	// adjust the addresses of JUMP_SLOT relocations
-	__ensure(object->lazyExplicitAddend.has_value());
-	size_t rel_size = (*object->lazyExplicitAddend) ? sizeof(elf_rela) : sizeof(elf_rel);
-
-	for(size_t offset = 0; offset < object->lazyTableSize; offset += rel_size) {
-		elf_info type;
-		elf_info symbol_index;
-
-		uintptr_t rel_addr;
-		uintptr_t addend [[maybe_unused]] = 0;
-
-		if(*object->lazyExplicitAddend) {
-			auto reloc = (elf_rela *)(object->baseAddress + object->lazyRelocTableOffset + offset);
-			type = ELF_R_TYPE(reloc->r_info);
-			symbol_index = ELF_R_SYM(reloc->r_info);
-			rel_addr = object->baseAddress + reloc->r_offset;
-			addend = reloc->r_addend;
-		} else {
-			auto reloc = (elf_rel *)(object->baseAddress + object->lazyRelocTableOffset + offset);
-			type = ELF_R_TYPE(reloc->r_info);
-			symbol_index = ELF_R_SYM(reloc->r_info);
-			rel_addr = object->baseAddress + reloc->r_offset;
-		}
-
-		switch (type) {
-		case R_JUMP_SLOT:
-			if(eagerBinding) {
-				auto [sym, ver] = object->getSymbolByIndex(symbol_index);
-				auto p = Scope::resolveGlobalOrLocal(*globalScope, object->localScope, sym.getString(), object->objectRts, 0, ver);
-
-				if(!p) {
-					if(ELF_ST_BIND(sym.symbol()->st_info) != STB_WEAK)
-						mlibc::panicLogger() << "rtld: Unresolved JUMP_SLOT symbol "
-								<< sym.getString() << " in object " << object->name << frg::endlog;
-
-					if(verbose)
-						mlibc::infoLogger() << "rtld: Unresolved weak JUMP_SLOT symbol "
-							<< sym.getString() << " in object " << object->name << frg::endlog;
-					*((uintptr_t *)rel_addr) = 0;
-				}else{
-					*((uintptr_t *)rel_addr) = p->virtualAddress();
-				}
-			}else{
-				*((uintptr_t *)rel_addr) += object->baseAddress;
-			}
-			break;
+  if (object->globalOffsetTable == nullptr) {
+    __ensure(object->lazyRelocTableOffset == 0);
+    return;
+  }
+  object->globalOffsetTable[1] = object;
+  object->globalOffsetTable[2] = (void *)&pltRelocateStub;
+
+  if (!object->lazyTableSize)
+    return;
+
+  // adjust the addresses of JUMP_SLOT relocations
+  __ensure(object->lazyExplicitAddend.has_value());
+  size_t rel_size =
+      (*object->lazyExplicitAddend) ? sizeof(elf_rela) : sizeof(elf_rel);
+
+  for (size_t offset = 0; offset < object->lazyTableSize; offset += rel_size) {
+    elf_info type;
+    elf_info symbol_index;
+
+    uintptr_t rel_addr;
+    uintptr_t addend [[maybe_unused]] = 0;
+
+    if (*object->lazyExplicitAddend) {
+      auto reloc = (elf_rela *)(object->baseAddress +
+                                object->lazyRelocTableOffset + offset);
+      type = ELF_R_TYPE(reloc->r_info);
+      symbol_index = ELF_R_SYM(reloc->r_info);
+      rel_addr = object->baseAddress + reloc->r_offset;
+      addend = reloc->r_addend;
+    } else {
+      auto reloc = (elf_rel *)(object->baseAddress +
+                               object->lazyRelocTableOffset + offset);
+      type = ELF_R_TYPE(reloc->r_info);
+      symbol_index = ELF_R_SYM(reloc->r_info);
+      rel_addr = object->baseAddress + reloc->r_offset;
+    }
+
+    switch (type) {
+    case R_JUMP_SLOT:
+      if (eagerBinding) {
+        auto [sym, ver] = object->getSymbolByIndex(symbol_index);
+        auto p = Scope::resolveGlobalOrLocal(*globalScope, object->localScope,
+                                             sym.getString(), object->objectRts,
+                                             0, ver);
+
+        if (!p) {
+          if (ELF_ST_BIND(sym.symbol()->st_info) != STB_WEAK)
+            mlibc::panicLogger()
+                << "rtld: Unresolved JUMP_SLOT symbol " << sym.getString()
+                << " in object " << object->name << frg::endlog;
+
+          if (verbose)
+            mlibc::infoLogger()
+                << "rtld: Unresolved weak JUMP_SLOT symbol " << sym.getString()
+                << " in object " << object->name << frg::endlog;
+          *((uintptr_t *)rel_addr) = 0;
+        } else {
+          *((uintptr_t *)rel_addr) = p->virtualAddress();
+        }
+      } else {
+        *((uintptr_t *)rel_addr) += object->baseAddress;
+      }
+      break;
 #if defined(__x86_64__)
-		case R_X86_64_IRELATIVE: {
-			auto ptr = object->baseAddress + addend;
-			auto target = reinterpret_cast<uintptr_t (*)(void)>(ptr)();
-			*((uintptr_t *)rel_addr) = target;
-			break;
-		}
+    case R_X86_64_IRELATIVE: {
+      auto ptr = object->baseAddress + addend;
+      auto target = reinterpret_cast<uintptr_t (*)(void)>(ptr)();
+      *((uintptr_t *)rel_addr) = target;
+      break;
+    }
 #endif
 // TODO: TLSDESC relocations aren't aarch64/x86_64 specific
 #if defined(__aarch64__) || defined(__x86_64__)
-		case R_TLSDESC: {
-			size_t symValue = 0;
-			SharedObject *target = nullptr;
-
-			if (symbol_index) {
-				auto [sym, ver] = object->getSymbolByIndex(symbol_index);
-				auto p = Scope::resolveGlobalOrLocal(*globalScope, object->localScope, sym.getString(), object->objectRts, 0, ver);
-
-				if (!p) {
-					__ensure(ELF_ST_BIND(sym.symbol()->st_info) != STB_WEAK);
-					mlibc::panicLogger() << "rtld: Unresolved TLSDESC for symbol "
-						<< sym.getString() << " in object " << object->name << frg::endlog;
-				} else {
-					target = p->object();
-					if (p->symbol())
-						symValue = p->symbol()->st_value;
-				}
-			} else {
-				target = object;
-			}
-
-			__ensure(target);
-
-			if (target->tlsModel == TlsModel::initial) {
-				((uint64_t *)rel_addr)[0] = reinterpret_cast<uintptr_t>(&__mlibcTlsdescStatic);
-				uint64_t value = symValue + target->tlsOffset + tlsOffsetFromTp + addend;
-				((uint64_t *)rel_addr)[1] = value;
-			} else {
-				struct TlsdescData {
-					uintptr_t tlsIndex;
-					uintptr_t addend;
-				};
-
-				// Access DTV for object to force the entry to be allocated and initialized
-				accessDtv(target);
-
-				__ensure(target->tlsIndex < mlibc::get_current_tcb()->dtvSize);
-
-				// TODO: We should free this when the DSO gets destroyed
-				auto data = frg::construct<TlsdescData>(getAllocator());
-				data->tlsIndex = target->tlsIndex;
-				data->addend = symValue + addend;
-
-				((uint64_t *)rel_addr)[0] = reinterpret_cast<uintptr_t>(&__mlibcTlsdescDynamic);
-				((uint64_t *)rel_addr)[1] = reinterpret_cast<uintptr_t>(data);
-			}
-		} break;
+    case R_TLSDESC: {
+      size_t symValue = 0;
+      SharedObject *target = nullptr;
+
+      if (symbol_index) {
+        auto [sym, ver] = object->getSymbolByIndex(symbol_index);
+        auto p = Scope::resolveGlobalOrLocal(*globalScope, object->localScope,
+                                             sym.getString(), object->objectRts,
+                                             0, ver);
+
+        if (!p) {
+          __ensure(ELF_ST_BIND(sym.symbol()->st_info) != STB_WEAK);
+          mlibc::panicLogger()
+              << "rtld: Unresolved TLSDESC for symbol " << sym.getString()
+              << " in object " << object->name << frg::endlog;
+        } else {
+          target = p->object();
+          if (p->symbol())
+            symValue = p->symbol()->st_value;
+        }
+      } else {
+        target = object;
+      }
+
+      __ensure(target);
+
+      if (target->tlsModel == TlsModel::initial) {
+        ((uint64_t *)rel_addr)[0] =
+            reinterpret_cast<uintptr_t>(&__mlibcTlsdescStatic);
+        uint64_t value =
+            symValue + target->tlsOffset + tlsOffsetFromTp + addend;
+        ((uint64_t *)rel_addr)[1] = value;
+      } else {
+        struct TlsdescData {
+          uintptr_t tlsIndex;
+          uintptr_t addend;
+        };
+
+        // Access DTV for object to force the entry to be allocated and
+        // initialized
+        accessDtv(target);
+
+        __ensure(target->tlsIndex < mlibc::get_current_tcb()->dtvSize);
+
+        // TODO: We should free this when the DSO gets destroyed
+        auto data = frg::construct<TlsdescData>(getAllocator());
+        data->tlsIndex = target->tlsIndex;
+        data->addend = symValue + addend;
+
+        ((uint64_t *)rel_addr)[0] =
+            reinterpret_cast<uintptr_t>(&__mlibcTlsdescDynamic);
+        ((uint64_t *)rel_addr)[1] = reinterpret_cast<uintptr_t>(data);
+      }
+    } break;
 #endif
-		default:
-			mlibc::panicLogger() << "unimplemented lazy relocation type " << type << frg::endlog;
-			break;
-		}
-	}
+    default:
+      mlibc::panicLogger() << "unimplemented lazy relocation type " << type
+                           << frg::endlog;
+      break;
+    }
+  }
 }
-
diff --git mlibc-workdir/sysdeps/nyaux/generic/entry.cpp mlibc-workdir/sysdeps/nyaux/generic/entry.cpp
new file mode 100644
index 0000000..9d0c66a
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/generic/entry.cpp
@@ -0,0 +1,18 @@
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/auxv.h>
+
+extern "C" void __dlapi_enter(uintptr_t *);
+
+extern char **environ;
+
+extern "C" void __mlibc_entry(uintptr_t *entry_stack,
+                              int (*main_fn)(int argc, char *argv[],
+                                             char *env[])) {
+  __dlapi_enter(entry_stack);
+  auto result =
+      main_fn(mlibc::entry_stack.argc, mlibc::entry_stack.argv, environ);
+  exit(result);
+}
diff --git mlibc-workdir/sysdeps/nyaux/generic/generic.cpp mlibc-workdir/sysdeps/nyaux/generic/generic.cpp
new file mode 100644
index 0000000..f6faf48
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/generic/generic.cpp
@@ -0,0 +1,385 @@
+#include "syscall.h"
+#include <asm/ioctls.h>
+#include <bits/ensure.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/debug.hpp>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#define STUB_ONLY                                                              \
+  {                                                                            \
+    __ensure(!"STUB_ONLY function was called");                                \
+    __builtin_unreachable();                                                   \
+  }
+
+namespace mlibc {
+
+void sys_libc_log(const char *message) {
+  __syscall2(1, (uint64_t)message, strlen(message));
+}
+void sys_exit(int status) {
+  __syscall1(0, status);
+  __builtin_unreachable();
+};
+void sys_libc_panic() {
+  sys_libc_log("\nMLIBC PANIC\n");
+  sys_exit(1);
+}
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd,
+               off_t offset, void **window) {
+  struct __syscall_ret ret =
+      __syscall6(3, (uint64_t)hint, (uint64_t)size, (uint64_t)prot,
+                 (uint64_t)flags, (uint64_t)fd, (uint64_t)offset);
+  *window = (void *)ret.ret;
+  return ret.err;
+};
+int sys_anon_allocate(size_t size, void **pointer) {
+  return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON, -1, 0,
+                    pointer);
+};
+int sys_vm_protect(void *pointer, size_t size, int prot) { return 0; }
+int sys_anon_free(void *pointer, size_t size) {
+  __syscall2(17, (uint64_t)pointer, size);
+  return 0;
+};
+int sys_close(int fd) {
+  __syscall_ret ret = __syscall1(7, fd);
+
+  if (ret.err != 0)
+    return ret.err;
+
+  return 0;
+};
+int sys_futex_wait(int *pointer, int expected,
+                   const struct timespec *time) STUB_ONLY;
+int sys_futex_wake(int *pointer) {
+  sys_libc_log("sys futex wake is a stub");
+  return 0;
+};
+int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
+  __syscall_ret ret = __syscall4(4, dirfd, (uint64_t)path, flags, mode);
+
+  if (ret.err != 0)
+    return ret.err;
+
+  *fd = (int)ret.ret;
+  return 0;
+}
+
+uid_t sys_geteuid() {
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n"
+                      << frg::endlog;
+  return 0;
+}
+int sys_gethostname(char *buffer, size_t bufsize) {
+  if (bufsize >= 6) {
+    memcpy(buffer, "nyaux", 6);
+  }
+  return 0;
+}
+
+gid_t sys_getgid() {
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n"
+                      << frg::endlog;
+  return 0;
+}
+
+int sys_setgid(gid_t gid) {
+  (void)gid;
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n"
+                      << frg::endlog;
+  return 0;
+}
+
+pid_t sys_getpgid(pid_t pid, pid_t *pgid) {
+  (void)pid;
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n"
+                      << frg::endlog;
+  *pgid = 0;
+  return 0;
+}
+
+gid_t sys_getegid() {
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n"
+                      << frg::endlog;
+  return 0;
+}
+
+int sys_setpgid(pid_t pid, pid_t pgid) {
+  (void)pid;
+  (void)pgid;
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n"
+                      << frg::endlog;
+  return 0;
+}
+
+int sys_ttyname(int fd, char *buf, size_t size) {
+  (void)fd;
+  (void)buf;
+  (void)size;
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n"
+                      << frg::endlog;
+  return ENOSYS;
+}
+uid_t sys_getuid() {
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n"
+                      << frg::endlog;
+  return 0;
+}
+int sys_open(const char *path, int flags, mode_t mode, int *fd) {
+  return sys_openat(AT_FDCWD, path, flags, mode, fd);
+}
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+  __syscall_ret ret = __syscall3(5, fd, (uint64_t)buf, count);
+
+  if (ret.err != 0) {
+    return ret.err;
+  }
+
+  *bytes_read = (ssize_t)ret.ret;
+  return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+  __syscall_ret ret = __syscall3(6, fd, offset, whence);
+
+  if (ret.err != 0) {
+    return ret.err;
+  }
+
+  *new_offset = (off_t)ret.ret;
+  return 0;
+}
+int sys_tcb_set(void *pointer) {
+  __syscall_ret ret = __syscall1(2, (uint64_t)pointer);
+  if (ret.err != 0) {
+    return ret.err;
+  }
+  return 0;
+};
+int sys_isatty(int fd) {
+  __syscall_ret ret = __syscall1(8, fd);
+  if (ret.err != 0) {
+    return ret.err;
+  }
+
+  return ret.ret;
+}
+int sys_vm_unmap(void *pointer, size_t size) STUB_ONLY;
+int sys_clock_get(int clock, time_t *secs, long *nanos) { return ENOSYS; }
+#ifndef MLIBC_BUILDING_RTLD
+int sys_getcwd(char *buffer, size_t size) {
+  __syscall_ret ret = __syscall2(13, (uint64_t)buffer, size);
+
+  if (ret.err != 0)
+    return ret.err;
+
+  return 0;
+}
+int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
+  __syscall_ret ret = __syscall3(9, fd, (uint64_t)buf, count);
+
+  if (ret.err != 0) {
+    return ret.err;
+  }
+
+  *bytes_written = (ssize_t)ret.ret;
+
+  return 0;
+}
+
+pid_t sys_getpid() {
+  __syscall_ret ret = __syscall0(16);
+  return ret.ret;
+}
+#endif
+pid_t sys_getppid() {
+  mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+
+  return 0;
+}
+#ifndef MLIBC_BUILDING_RTLD
+int sys_fork(pid_t *child) {
+  __syscall_ret ret = __syscall0(14);
+
+  if (ret.err != 0) {
+    return ret.err;
+  }
+
+  *child = (pid_t)ret.ret;
+  return 0;
+}
+int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
+  __syscall_ret ret = __syscall3(10, fd, request, (uint64_t)arg);
+
+  if (ret.err != 0)
+    return ret.err;
+  *result = (int)ret.ret;
+  return 0;
+}
+int sys_fcntl(int fd, int request, va_list args, int *result) {
+  // __syscall_ret ret = __syscall(12, fd, request, va_arg(args, uint64_t));
+
+  // if (ret.errno != 0)
+  // 	return ret.errno;
+
+  // *result = (ssize_t)ret.ret;
+  // return 0;
+  mlibc::infoLogger() << "mlibc: fd " << fd << " request " << request
+                      << frg::endlog;
+  return ENOSYS;
+}
+int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set,
+                fd_set *except_set, const struct timespec *timeout,
+                const sigset_t *sigmask, int *num_events) {
+  // fuck off bash
+  fd_set res_read_set;
+  fd_set res_write_set;
+  fd_set res_except_set;
+  FD_ZERO(&res_read_set);
+  FD_ZERO(&res_write_set);
+  FD_ZERO(&res_except_set);
+  for (int i = 0; i < nfds; i++) {
+    if (read_set && FD_ISSET(i, read_set)) {
+      FD_SET(i, &res_read_set);
+    }
+    if (write_set && FD_ISSET(i, write_set)) {
+      FD_SET(i, &res_write_set);
+    }
+    if (except_set && FD_ISSET(i, except_set)) {
+      FD_SET(i, &res_except_set);
+    }
+  }
+  if (read_set)
+    *read_set = res_read_set;
+  if (write_set)
+    *write_set = res_write_set;
+  if (except_set)
+    *except_set = res_except_set;
+  *num_events = 1;
+  return 0;
+}
+int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
+  int ret;
+
+  switch (optional_action) {
+  case TCSANOW:
+    optional_action = TCSETS;
+    break;
+  case TCSADRAIN:
+    return ENOSYS;
+    break;
+  case TCSAFLUSH:
+    return ENOSYS;
+    break;
+  default:
+    __ensure(!"Unsupported tcsetattr");
+  }
+
+  if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0) {
+    return r;
+  }
+
+  return 0;
+}
+int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru,
+                pid_t *ret_pid) {
+  if (ru) {
+    mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported"
+                        << frg::endlog;
+    return ENOSYS;
+  }
+
+again:
+  __syscall_ret ret = __syscall3(15, pid, (uint64_t)status, flags);
+
+  if (ret.err != 0) {
+    if (ret.err == EINTR) {
+      goto again;
+    }
+
+    return ret.err;
+  }
+
+  *ret_pid = (pid_t)ret.ret;
+  return 0;
+}
+int sys_execve(const char *path, char *const argv[], char *const envp[]) {
+  __syscall_ret ret =
+      __syscall3(18, (uint64_t)path, (uint64_t)argv, (uint64_t)envp);
+  if (ret.ret != 0) {
+    return ret.err;
+  } else {
+    __builtin_unreachable();
+  }
+}
+#endif
+int sys_sigprocmask(int how, const sigset_t *__restrict set,
+                    sigset_t *__restrict retrieve) {
+  return ENOSYS;
+}
+int sys_sigaction(int signum, const struct sigaction *act,
+                  struct sigaction *oldact) {
+  return ENOSYS;
+}
+int sys_tcgetattr(int fd, struct termios *attr) {
+  int ret;
+
+  if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0) {
+    return r;
+  }
+
+  return 0;
+}
+int sys_dup(int fd, int flags, int *newfd) {
+  (void)flags;
+  __syscall_ret ret = __syscall2(11, fd, flags);
+
+  if (ret.err != 0)
+    return ret.err;
+
+  *newfd = (ssize_t)ret.ret;
+  return 0;
+}
+int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags,
+             struct stat *statbuf) {
+  __syscall_ret ret;
+  switch (fsfdt) {
+  case fsfd_target::fd: {
+    mlibc::infoLogger() << "mlibc: statfd is a stub" << frg::endlog;
+    ret = __syscall2(12, fd, (uint64_t)statbuf);
+    break;
+  }
+  case fsfd_target::path: {
+    int fd = 0;
+    int bad = sys_openat(AT_FDCWD, path, flags, O_RDONLY, &fd);
+    if (bad != 0) {
+      return bad;
+    }
+    ret = __syscall2(12, fd, (uint64_t)statbuf);
+    bad = sys_close(fd);
+    // ret = __syscall(11, AT_FDCWD, path, statbuf, flags);
+    break;
+  }
+  case fsfd_target::fd_path: {
+    mlibc::infoLogger() << "mlibc: statfd_path is a stub" << frg::endlog;
+    // ret = __syscall(11, fd, path, statbuf, flags);
+    return ENOSYS;
+    break;
+  }
+  default: {
+    __ensure(!"stat: Invalid fsfdt");
+    __builtin_unreachable();
+  }
+  }
+  if (ret.err != 0)
+    return ret.err;
+  return ret.ret;
+}
+
+} // namespace mlibc
diff --git mlibc-workdir/sysdeps/nyaux/generic/syscall.h mlibc-workdir/sysdeps/nyaux/generic/syscall.h
new file mode 100644
index 0000000..05aa39d
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/generic/syscall.h
@@ -0,0 +1,76 @@
+#pragma once
+#include <stdint.h>
+struct __syscall_ret {
+  uint64_t ret;
+  uint64_t err;
+};
+
+static __syscall_ret __syscall6(int number, uint64_t arg1, uint64_t arg2,
+                                uint64_t arg3, uint64_t arg4, uint64_t arg5,
+                                uint64_t arg6) {
+  struct __syscall_ret ret;
+  register uint64_t arg_r8 asm("r8") = arg4;
+  register uint64_t arg_r9 asm("r9") = arg5;
+  register uint64_t arg_r10 asm("r10") = arg6;
+  asm volatile("syscall"
+               : "=a"(ret.ret), "=d"(ret.err)
+               : "a"(number), "D"(arg1), "S"(arg2), "d"(arg3), "r"(arg_r8),
+                 "r"(arg_r9), "r"(arg_r10)
+               : "rcx", "r11", "memory");
+  return ret;
+}
+static __syscall_ret __syscall5(int number, uint64_t arg1, uint64_t arg2,
+                                uint64_t arg3, uint64_t arg4, uint64_t arg5) {
+  struct __syscall_ret ret;
+  register uint64_t arg_r8 asm("r8") = arg4;
+  register uint64_t arg_r9 asm("r9") = arg5;
+  asm volatile("syscall"
+               : "=a"(ret.ret), "=d"(ret.err)
+               : "a"(number), "D"(arg1), "S"(arg2), "d"(arg3), "r"(arg_r8),
+                 "r"(arg_r9)
+               : "rcx", "r11", "memory");
+  return ret;
+}
+static __syscall_ret __syscall4(int number, uint64_t arg1, uint64_t arg2,
+                                uint64_t arg3, uint64_t arg4) {
+  struct __syscall_ret ret;
+  register uint64_t arg_r8 asm("r8") = arg4;
+  asm volatile("syscall"
+               : "=a"(ret.ret), "=d"(ret.err)
+               : "a"(number), "D"(arg1), "S"(arg2), "d"(arg3), "r"(arg_r8)
+               : "rcx", "r11", "memory");
+  return ret;
+}
+static __syscall_ret __syscall3(int number, uint64_t arg1, uint64_t arg2,
+                                uint64_t arg3) {
+  struct __syscall_ret ret;
+  asm volatile("syscall"
+               : "=a"(ret.ret), "=d"(ret.err)
+               : "a"(number), "D"(arg1), "S"(arg2), "d"(arg3)
+               : "rcx", "r11", "memory");
+  return ret;
+}
+static __syscall_ret __syscall2(int number, uint64_t arg1, uint64_t arg2) {
+  struct __syscall_ret ret;
+  asm volatile("syscall"
+               : "=a"(ret.ret), "=d"(ret.err)
+               : "a"(number), "D"(arg1), "S"(arg2)
+               : "rcx", "r11", "memory");
+  return ret;
+}
+static __syscall_ret __syscall1(int number, uint64_t arg1) {
+  struct __syscall_ret ret;
+  asm volatile("syscall"
+               : "=a"(ret.ret), "=d"(ret.err)
+               : "a"(number), "D"(arg1)
+               : "rcx", "r11", "memory");
+  return ret;
+}
+static __syscall_ret __syscall0(int number) {
+  struct __syscall_ret ret;
+  asm volatile("syscall"
+               : "=a"(ret.ret), "=d"(ret.err)
+               : "a"(number)
+               : "rcx", "r11", "memory");
+  return ret;
+}
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/access.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/access.h
new file mode 120000
index 0000000..cb83931
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/access.h
@@ -0,0 +1 @@
+../../../../abis/linux/access.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/auxv.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/auxv.h
new file mode 120000
index 0000000..c43f878
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/linux/auxv.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/blkcnt_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/blkcnt_t.h
new file mode 120000
index 0000000..0b0ec27
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blkcnt_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/blksize_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/blksize_t.h
new file mode 120000
index 0000000..7dc8d7c
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blksize_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/clockid_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/clockid_t.h
new file mode 120000
index 0000000..6a42da5
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/clockid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/clockid_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/dev_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/dev_t.h
new file mode 120000
index 0000000..bca881e
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/dev_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/errno.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/errno.h
new file mode 120000
index 0000000..6e507de
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/linux/errno.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/fcntl.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/fcntl.h
new file mode 120000
index 0000000..463e2c9
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/linux/fcntl.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/fsblkcnt_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/fsblkcnt_t.h
new file mode 120000
index 0000000..898dfb2
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/fsblkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsblkcnt_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/fsfilcnt_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/fsfilcnt_t.h
new file mode 120000
index 0000000..791755c
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/fsfilcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsfilcnt_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/gid_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/gid_t.h
new file mode 120000
index 0000000..abce6d6
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/gid_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/in.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/in.h
new file mode 120000
index 0000000..418d1d5
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/linux/in.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/ino_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/ino_t.h
new file mode 120000
index 0000000..4c20aca
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/ino_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/ioctls.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/ioctls.h
new file mode 120000
index 0000000..595106b
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/ioctls.h
@@ -0,0 +1 @@
+../../../../abis/linux/ioctls.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/ipc.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/ipc.h
new file mode 120000
index 0000000..2c7ffc4
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/ipc.h
@@ -0,0 +1 @@
+../../../../abis/linux/ipc.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/limits.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/limits.h
new file mode 120000
index 0000000..6c88db2
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/limits.h
@@ -0,0 +1 @@
+../../../../abis/linux/limits.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/mode_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/mode_t.h
new file mode 120000
index 0000000..5d78fdf
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/mode_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/mqueue.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/mqueue.h
new file mode 120000
index 0000000..fa87b07
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/mqueue.h
@@ -0,0 +1 @@
+../../../../abis/linux/mqueue.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/msg.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/msg.h
new file mode 120000
index 0000000..f402b49
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/msg.h
@@ -0,0 +1 @@
+../../../../abis/linux/msg.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/nlink_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/nlink_t.h
new file mode 120000
index 0000000..bb3b625
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/nlink_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/packet.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/packet.h
new file mode 120000
index 0000000..998ef1a
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/packet.h
@@ -0,0 +1 @@
+../../../../abis/linux/packet.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/pid_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/pid_t.h
new file mode 120000
index 0000000..baa90f6
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/pid_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/poll.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/poll.h
new file mode 120000
index 0000000..8ea6a0a
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/poll.h
@@ -0,0 +1 @@
+../../../../abis/linux/poll.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/reboot.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/reboot.h
new file mode 120000
index 0000000..e17dce3
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/reboot.h
@@ -0,0 +1 @@
+../../../../abis/vinix/reboot.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/resource.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/resource.h
new file mode 120000
index 0000000..88d7402
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/linux/resource.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/rlim_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/rlim_t.h
new file mode 120000
index 0000000..e92eb5f
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/rlim_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/rlim_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/seek-whence.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/seek-whence.h
new file mode 120000
index 0000000..df7bccf
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/linux/seek-whence.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/shm.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/shm.h
new file mode 120000
index 0000000..067d8c4
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/shm.h
@@ -0,0 +1 @@
+../../../../abis/linux/shm.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/sigevent.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/sigevent.h
new file mode 120000
index 0000000..76ef0a2
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/sigevent.h
@@ -0,0 +1 @@
+../../../../abis/vinix/sigevent.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/signal.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/signal.h
new file mode 120000
index 0000000..709546b
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/vinix/signal.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/sigval.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/sigval.h
new file mode 120000
index 0000000..ccd43a5
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/sigval.h
@@ -0,0 +1 @@
+../../../../abis/linux/sigval.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/socket.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/socket.h
new file mode 120000
index 0000000..f1dc016
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/linux/socket.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/socklen_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/socklen_t.h
new file mode 120000
index 0000000..41f3b11
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/socklen_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/socklen_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/stat.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/stat.h
new file mode 120000
index 0000000..1f63b41
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/linux/stat.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/statvfs.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/statvfs.h
new file mode 120000
index 0000000..cb4eaf1
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/statvfs.h
@@ -0,0 +1 @@
+../../../../abis/vinix/statvfs.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/suseconds_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/suseconds_t.h
new file mode 120000
index 0000000..9ed6597
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/suseconds_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/suseconds_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/termios.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/termios.h
new file mode 120000
index 0000000..ee8f0b0
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/linux/termios.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/time.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/time.h
new file mode 120000
index 0000000..2a02625
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/linux/time.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/uid_t.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/uid_t.h
new file mode 120000
index 0000000..b306777
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/uid_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/utsname.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/utsname.h
new file mode 120000
index 0000000..b285754
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/utsname.h
@@ -0,0 +1 @@
+../../../../abis/linux/utsname.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/vm-flags.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/vm-flags.h
new file mode 120000
index 0000000..bbe258c
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/linux/vm-flags.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/abi-bits/wait.h mlibc-workdir/sysdeps/nyaux/include/abi-bits/wait.h
new file mode 120000
index 0000000..feb2840
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/abi-bits/wait.h
@@ -0,0 +1 @@
+../../../../abis/linux/wait.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/nyaux/include/asm/ioctl.h mlibc-workdir/sysdeps/nyaux/include/asm/ioctl.h
new file mode 100644
index 0000000..8cbb364
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/asm/ioctl.h
@@ -0,0 +1,105 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _ASM_GENERIC_IOCTL_H
+#define _ASM_GENERIC_IOCTL_H
+
+/* ioctl command encoding: 32 bits total, command in lower 16 bits,
+ * size of the parameter structure in the lower 14 bits of the
+ * upper 16 bits.
+ * Encoding the size of the parameter structure in the ioctl request
+ * is useful for catching programs compiled with old versions
+ * and to avoid overwriting user space outside the user buffer area.
+ * The highest 2 bits are reserved for indicating the ``access mode''.
+ * NOTE: This limits the max parameter size to 16kB -1 !
+ */
+
+/*
+ * The following is for compatibility across the various Linux
+ * platforms.  The generic ioctl numbering scheme doesn't really enforce
+ * a type field.  De facto, however, the top 8 bits of the lower 16
+ * bits are indeed used as a type field, so we might just as well make
+ * this explicit here.  Please be sure to use the decoding macros
+ * below from now on.
+ */
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+
+/*
+ * Let any architecture override either of the following before
+ * including this file.
+ */
+
+#ifndef _IOC_SIZEBITS
+# define _IOC_SIZEBITS	14
+#endif
+
+#ifndef _IOC_DIRBITS
+# define _IOC_DIRBITS	2
+#endif
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * Direction bits, which any architecture can choose to override
+ * before including this file.
+ *
+ * NOTE: _IOC_WRITE means userland is writing and kernel is
+ * reading. _IOC_READ means userland is reading and kernel is writing.
+ */
+
+#ifndef _IOC_NONE
+# define _IOC_NONE	0U
+#endif
+
+#ifndef _IOC_WRITE
+# define _IOC_WRITE	1U
+#endif
+
+#ifndef _IOC_READ
+# define _IOC_READ	2U
+#endif
+
+#define _IOC(dir,type,nr,size) \
+	(((dir)  << _IOC_DIRSHIFT) | \
+	 ((type) << _IOC_TYPESHIFT) | \
+	 ((nr)   << _IOC_NRSHIFT) | \
+	 ((size) << _IOC_SIZESHIFT))
+
+#define _IOC_TYPECHECK(t) (sizeof(t))
+
+/*
+ * Used to create numbers.
+ *
+ * NOTE: _IOW means userland is writing and kernel is reading. _IOR
+ * means userland is reading and kernel is writing.
+ */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASM_GENERIC_IOCTL_H */
diff --git mlibc-workdir/sysdeps/nyaux/include/asm/ioctls.h mlibc-workdir/sysdeps/nyaux/include/asm/ioctls.h
new file mode 100644
index 0000000..bdbba9b
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/asm/ioctls.h
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef __ASM_GENERIC_IOCTLS_H
+#define __ASM_GENERIC_IOCTLS_H
+
+#include <asm/ioctl.h>
+
+/*
+ * These are the most common definitions for tty ioctl numbers.
+ * Most of them do not use the recommended _IOC(), but there is
+ * probably some source code out there hardcoding the number,
+ * so we might as well use them for all new platforms.
+ *
+ * The architectures that use different values here typically
+ * try to be compatible with some Unix variants for the same
+ * architecture.
+ */
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TCGETS2		_IOR('T', 0x2A, struct termios2)
+#define TCSETS2		_IOW('T', 0x2B, struct termios2)
+#define TCSETSW2	_IOW('T', 0x2C, struct termios2)
+#define TCSETSF2	_IOW('T', 0x2D, struct termios2)
+#define TIOCGRS485	0x542E
+#ifndef TIOCSRS485
+#define TIOCSRS485	0x542F
+#endif
+#define TIOCGPTN	_IOR('T', 0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T', 0x31, int)  /* Lock/unlock Pty */
+#define TIOCGDEV	_IOR('T', 0x32, unsigned int) /* Get primary device node of /dev/console */
+#define TCGETX		0x5432 /* SYS5 TCGETX compatibility */
+#define TCSETX		0x5433
+#define TCSETXF		0x5434
+#define TCSETXW		0x5435
+#define TIOCSIG		_IOW('T', 0x36, int)  /* pty: generate signal */
+#define TIOCVHANGUP	0x5437
+#define TIOCGPKT	_IOR('T', 0x38, int) /* Get packet mode state */
+#define TIOCGPTLCK	_IOR('T', 0x39, int) /* Get Pty lock state */
+#define TIOCGEXCL	_IOR('T', 0x40, int) /* Get exclusive mode state */
+#define TIOCGPTPEER	_IO('T', 0x41) /* Safely open the slave */
+#define TIOCGISO7816	_IOR('T', 0x42, struct serial_iso7816)
+#define TIOCSISO7816	_IOWR('T', 0x43, struct serial_iso7816)
+
+#define FIONCLEX	0x5450
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port __inline__ interrupt counts */
+
+/*
+ * Some arches already define FIOQSIZE due to a historical
+ * conflict with a Hayes modem-specific ioctl value.
+ */
+#ifndef FIOQSIZE
+# define FIOQSIZE	0x5460
+#endif
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+#define TIOCPKT_IOCTL		64
+
+#define TIOCSER_TEMT	0x01	/* Transmitter physically empty */
+
+#endif /* __ASM_GENERIC_IOCTLS_H */
diff --git mlibc-workdir/sysdeps/nyaux/include/linux/fb.h mlibc-workdir/sysdeps/nyaux/include/linux/fb.h
new file mode 100644
index 0000000..d5e6d88
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/linux/fb.h
@@ -0,0 +1,400 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <stddef.h>
+#include <asm/ioctl.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, uint32_t)
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+#define FB_TYPE_FOURCC			5	/* Type identified by a V4L2 FOURCC */
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+#define FB_VISUAL_FOURCC		6	/* Visual identified by a V4L2 FOURCC */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+#define FB_ACCEL_PUV3_UNIGFX	0xa0	/* PKUnity-v3 Unigfx		*/
+
+#define FB_CAP_FOURCC		1	/* Device supports FOURCC-based formats */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	uint32_t smem_len;			/* Length of frame buffer mem */
+	uint32_t type;			/* see FB_TYPE_*		*/
+	uint32_t type_aux;			/* Interleave for interleaved Planes */
+	uint32_t visual;			/* see FB_VISUAL_*		*/ 
+	uint16_t xpanstep;			/* zero if no hardware panning  */
+	uint16_t ypanstep;			/* zero if no hardware panning  */
+	uint16_t ywrapstep;		/* zero if no hardware ywrap    */
+	uint32_t line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	uint32_t mmio_len;			/* Length of Memory Mapped I/O  */
+	uint32_t accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	uint16_t capabilities;		/* see FB_CAP_*			*/
+	uint16_t reserved[2];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the palette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
+ */
+struct fb_bitfield {
+	uint32_t offset;			/* beginning of bitfield	*/
+	uint32_t length;			/* length of bitfield		*/
+	uint32_t msb_right;		/* != 0 : Most significant bit is */ 
+					/* right */ 
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+#define FB_ACTIVATE_KD_TEXT   512       /* for KDSET vt ioctl */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	uint32_t xres;			/* visible resolution		*/
+	uint32_t yres;
+	uint32_t xres_virtual;		/* virtual resolution		*/
+	uint32_t yres_virtual;
+	uint32_t xoffset;			/* offset from virtual to visible */
+	uint32_t yoffset;			/* resolution			*/
+
+	uint32_t bits_per_pixel;		/* guess what			*/
+	uint32_t grayscale;		/* 0 = color, 1 = grayscale,	*/
+					/* >1 = FOURCC			*/
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/	
+
+	uint32_t nonstd;			/* != 0 Non standard pixel format */
+
+	uint32_t activate;			/* see FB_ACTIVATE_*		*/
+
+	uint32_t height;			/* height of picture in mm    */
+	uint32_t width;			/* width of picture in mm     */
+
+	uint32_t accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	uint32_t pixclock;			/* pixel clock in ps (pico seconds) */
+	uint32_t left_margin;		/* time from sync to picture	*/
+	uint32_t right_margin;		/* time from picture to sync	*/
+	uint32_t upper_margin;		/* time from sync to picture	*/
+	uint32_t lower_margin;
+	uint32_t hsync_len;		/* length of horizontal sync	*/
+	uint32_t vsync_len;		/* length of vertical sync	*/
+	uint32_t sync;			/* see FB_SYNC_*		*/
+	uint32_t vmode;			/* see FB_VMODE_*		*/
+	uint32_t rotate;			/* angle we rotate counter clockwise */
+	uint32_t colorspace;		/* colorspace for FOURCC-based modes */
+	uint32_t reserved[4];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	uint32_t start;			/* First entry	*/
+	uint32_t len;			/* Number of entries */
+	uint16_t *red;			/* Red values	*/
+	uint16_t *green;
+	uint16_t *blue;
+	uint16_t *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	uint32_t console;
+	uint32_t framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	uint32_t flags;			/* FB_VBLANK flags */
+	uint32_t count;			/* counter of retraces since boot */
+	uint32_t vcount;			/* current scanline position */
+	uint32_t hcount;			/* current scandot position */
+	uint32_t reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	uint32_t dx;
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t sx;
+	uint32_t sy;
+};
+
+struct fb_fillrect {
+	uint32_t dx;	/* screen-relative */
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t color;
+	uint32_t rop;
+};
+
+struct fb_image {
+	uint32_t dx;		/* Where to place image */
+	uint32_t dy;
+	uint32_t width;		/* Size of image */
+	uint32_t height;
+	uint32_t fg_color;		/* Only used when a mono bitmap */
+	uint32_t bg_color;
+	uint8_t  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	uint16_t x, y;
+};
+
+struct fb_cursor {
+	uint16_t set;		/* what to set */
+	uint16_t enable;		/* cursor on/off */
+	uint16_t rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+
+
+#endif /* _LINUX_FB_H */
diff --git mlibc-workdir/sysdeps/nyaux/include/mntent.h mlibc-workdir/sysdeps/nyaux/include/mntent.h
new file mode 100644
index 0000000..42f0184
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/mntent.h
@@ -0,0 +1,50 @@
+#ifndef _MNTENT_H
+#define _MNTENT_H
+
+#include <stdio.h>
+
+/* TODO: Refer to _PATH_MOUNTED */
+#define MOUNTED "/etc/mtab"
+
+/* Generic mount options */
+#define MNTOPT_DEFAULTS "defaults"		/* Use all default options. */
+#define MNTOPT_RO       "ro"			/* Read only. */
+#define MNTOPT_RW       "rw"			/* Read/write. */
+#define MNTOPT_SUID     "suid"			/* Set uid allowed. */
+#define MNTOPT_NOSUID   "nosuid"		/* No set uid allowed. */
+#define MNTOPT_NOAUTO   "noauto"		/* Do not auto mount. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct mntent {
+	char *mnt_fsname;
+	char *mnt_dir;
+	char *mnt_type;
+	char *mnt_opts;
+	int mnt_freq;
+	int mnt_passno;
+};
+
+#ifndef __MLIBC_ABI_ONLY
+
+FILE *setmntent(const char *, const char *);
+
+struct mntent *getmntent(FILE *);
+
+int addmntent(FILE *, const struct mntent *);
+
+int endmntent(FILE *);
+
+char *hasmntopt(const struct mntent *, const char *);
+
+struct mntent *getmntent_r(FILE *, struct mntent *,  char *, int);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MNTENT_H */
diff --git mlibc-workdir/sysdeps/nyaux/include/sys/mount.h mlibc-workdir/sysdeps/nyaux/include/sys/mount.h
new file mode 100644
index 0000000..844abdb
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/sys/mount.h
@@ -0,0 +1,54 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MS_RDONLY 1
+#define MS_NOSUID 2
+#define MS_NODEV 4
+#define MS_NOEXEC 8
+#define MS_SYNCHRONOUS 16
+#define MS_REMOUNT 32
+#define MS_MANDLOCK 64
+#define MS_DIRSYNC 128
+#define MS_NOSYMFOLLOW 256
+#define MS_NOATIME 1024
+#define MS_NODIRATIME 2048
+#define MS_BIND 4096
+#define MS_MOVE 8192
+#define MS_REC 16384
+#define MS_SILENT 32768
+#define MS_POSIXACL (1 << 16)
+#define MS_UNBINDABLE (1 << 17)
+#define MS_PRIVATE (1 << 18)
+#define MS_SLAVE (1 << 19)
+#define MS_SHARED (1 << 20)
+#define MS_RELATIME (1 << 21)
+#define MS_KERNMOUNT (1 << 22)
+#define MS_I_VERSION (1 << 23)
+#define MS_STRICTATIME (1 << 24)
+#define MS_LAZYTIME (1 << 25)
+#define MS_NOREMOTELOCK (1 << 27)
+#define MS_NOSEC (1 << 28)
+#define MS_BORN (1 << 29)
+#define MS_ACTIVE (1 << 30)
+#define MS_NOUSER (1 << 31)
+
+#define MNT_FORCE 1
+
+#ifndef __MLIBC_ABI_ONLY
+
+int mount(const char *source, const char *target,
+		const char *fstype, unsigned long flags, const void *data);
+int umount(const char *target);
+int umount2(const char *target, int flags);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_MOUNT_H */
diff --git mlibc-workdir/sysdeps/nyaux/include/sys/reboot.h mlibc-workdir/sysdeps/nyaux/include/sys/reboot.h
new file mode 100644
index 0000000..0628ae4
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/sys/reboot.h
@@ -0,0 +1,20 @@
+#ifndef MLIBC_SYS_REBOOT_H
+#define MLIBC_SYS_REBOOT_H
+
+#include <abi-bits/reboot.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __MLIBC_ABI_ONLY
+
+int reboot(int arg);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MLIBC_SYS_REBOOT_H */
diff --git mlibc-workdir/sysdeps/nyaux/include/sys/sysmacros.h mlibc-workdir/sysdeps/nyaux/include/sys/sysmacros.h
new file mode 100644
index 0000000..9682d01
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/sys/sysmacros.h
@@ -0,0 +1,33 @@
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static unsigned int __mlibc_dev_major(
+		unsigned long long int __dev) {
+  return ((__dev >> 8) & 0xfff) | ((unsigned int)(__dev >> 32) & ~0xfff);
+}
+
+static unsigned int __mlibc_dev_minor(
+		unsigned long long int __dev) {
+  return (__dev & 0xff) | ((unsigned int)(__dev >> 12) & ~0xff);
+}
+
+static unsigned long long int __mlibc_dev_makedev(
+		unsigned int __major, unsigned int __minor) {
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+	  | (((unsigned long long int)(__minor & ~0xff)) << 12)
+	  | (((unsigned long long int)(__major & ~0xfff)) << 32));
+}
+
+#define major(dev) __mlibc_dev_major(dev)
+#define minor(dev) __mlibc_dev_minor(dev)
+#define makedev(major, minor) __mlibc_dev_makedev(major, minor)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_SYSMACROS_H */
diff --git mlibc-workdir/sysdeps/nyaux/include/utmpx.h mlibc-workdir/sysdeps/nyaux/include/utmpx.h
new file mode 100644
index 0000000..d479f6d
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/include/utmpx.h
@@ -0,0 +1,63 @@
+
+#ifndef  _UTMPX_H
+#define  _UTMPX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <abi-bits/pid_t.h>
+#include <bits/posix/timeval.h>
+
+#define UTMPX_FILE "/var/run/utmp"
+#define WTMPX_FILE "/var/run/wtmp"
+
+/* Struct definition taken from musl */
+struct utmpx {
+	short ut_type;
+	short __ut_pad1;
+	pid_t ut_pid;
+	char ut_line[32];
+	char ut_id[4];
+	char ut_user[32];
+	char ut_host[256];
+	struct {
+		short __e_termination;
+		short __e_exit;
+	} ut_exit;
+	int ut_session, __ut_pad2;
+	struct timeval ut_tv;
+	unsigned ut_addr_v6[4];
+	char __unused[20];
+};
+
+#ifndef __MLIBC_ABI_ONLY
+
+void updwtmpx(const char *, const struct utmpx *);
+int utmpxname(const char *);
+struct utmpx *pututxline(const struct utmpx *);
+struct utmpx *getutxent(void);
+void setutxent(void);
+void endutxent(void);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#define EMPTY           0
+#define RUN_LVL         1
+#define BOOT_TIME       2
+#define NEW_TIME        3
+#define OLD_TIME        4
+#define INIT_PROCESS    5
+#define LOGIN_PROCESS   6
+#define USER_PROCESS    7
+#define DEAD_PROCESS    8
+
+#define __UT_HOSTSIZE 256
+#define __UT_NAMESIZE 32
+#define __UT_LINESIZE 32
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UTMPX_H */
diff --git mlibc-workdir/sysdeps/nyaux/meson.build mlibc-workdir/sysdeps/nyaux/meson.build
new file mode 100644
index 0000000..e6b48bd
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/meson.build
@@ -0,0 +1,117 @@
+sysdep_supported_options = {
+	'posix': true,
+	'linux': false,
+	'glibc': true,
+	'bsd': true,
+}
+
+rtld_sources += files(
+	'generic/generic.cpp'
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/generic.cpp'
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/reboot.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/limits.h',
+		'include/abi-bits/utsname.h',
+		'include/abi-bits/poll.h',
+		'include/abi-bits/packet.h',
+		'include/abi-bits/clockid_t.h',
+		'include/abi-bits/ipc.h',
+		'include/abi-bits/shm.h',
+		'include/abi-bits/mqueue.h',
+		'include/abi-bits/suseconds_t.h',
+		'include/abi-bits/fsfilcnt_t.h',
+		'include/abi-bits/fsblkcnt_t.h',
+		'include/abi-bits/socklen_t.h',
+		'include/abi-bits/statvfs.h',
+		'include/abi-bits/ioctls.h',
+		'include/abi-bits/msg.h',
+		'include/abi-bits/rlim_t.h',
+		'include/abi-bits/sigval.h',
+		'include/abi-bits/sigevent.h',
+		subdir: 'abi-bits',
+		follow_symlinks: true
+	)
+
+	install_headers(
+		'include/asm/ioctl.h',
+		'include/asm/ioctls.h',
+		subdir: 'asm',
+	)
+
+	install_headers(
+		'include/linux/fb.h',
+		subdir: 'linux',
+	)
+
+	install_headers(
+		'include/sys/reboot.h',
+		'include/sys/mount.h',
+		'include/sys/sysmacros.h',
+		subdir: 'sys',
+	)
+
+	install_headers(
+		'include/mntent.h',
+		'include/utmpx.h',
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crti',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crti.S',
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crtn',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crtn.S',
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
diff --git mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crt0.S mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crt0.S
new file mode 100644
index 0000000..d0e8213
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crt0.S
@@ -0,0 +1,8 @@
+.section .text
+.global _start
+_start:
+	mov %rsp, %rdi
+	lea main(%rip), %rsi
+	call __mlibc_entry
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crti.S mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crti.S
new file mode 100644
index 0000000..911b078
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crti.S
@@ -0,0 +1,11 @@
+.section .init
+.global _init
+_init:
+	push %rax
+
+.section .fini
+.global _fini
+_fini:
+	push %rax
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crtn.S mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crtn.S
new file mode 100644
index 0000000..0187e50
--- /dev/null
+++ mlibc-workdir/sysdeps/nyaux/x86_64/crt-src/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	pop %rax
+	ret
+
+.section .fini
+	pop %rax
+	ret
+.section .note.GNU-stack,"",%progbits
+
